<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/dululu/notes</id><title>RSS feed of dululu's notes</title><updated>2024-01-14T15:22:32.761049+00:00</updated><link href="https://github.com/dululu/notes"/><link href="https://raw.githubusercontent.com/dululu/notes/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/dululu/notes/issues/20</id><title>Neovim </title><updated>2024-01-14T15:22:33.170696+00:00</updated><content type="html"><![CDATA[<h3>Step1:安装<a href="https://github.com/neovim/neovim/blob/master/INSTALL.md">Neovim</a></h3>
<p>Ubuntu+WSL</p>
<pre><code class="language-powershell-interactive">sudo apt-get install python-dev python-pip python3-dev
sudo apt-get install python3-setuptools
sudo easy_install3 pip
//卸载
sudo cmake --build build/ --target uninstall
</code></pre>
<h3>Step2:Neovim 基础配置</h3>
<p>Neovim 配置文件不是<code> .vimrc</code></p>
<p>而是保存在<code> ~/.config/nvim/init.vim</code>,但是 init.vim 只作为入口，真正的配置，是加载的其他的 lua 配置文件
<a href="https://martinlwx.github.io/zh-cn/config-neovim-from-scratch/">写的太好了😎😎😎</a></p>
<p>😅 然而我还没弄好 @dululu [2024年01月14日 23:21:49] </p>
]]></content><link href="https://github.com/dululu/notes/issues/20"/><published>2024-01-14T15:21:59+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/19</id><title>C++</title><updated>2024-01-14T15:22:33.336565+00:00</updated><content type="html"><![CDATA[<ol>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129283639">c++基础/类和对象</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129318605">c++继承机制</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129325451">虚函数与多态性</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129407024">c++指针</a></li>
</ol>
<p><strong>https://github.com/jiayuancs/Cpp-Primer</strong></p>
]]></content><link href="https://github.com/dululu/notes/issues/19"/><category term="cpp"/><published>2024-01-11T16:13:14+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/18</id><title>快速学习C和C++，基础语法和优化策略（三）</title><updated>2024-01-14T15:22:33.502790+00:00</updated><content type="html"><![CDATA[<h3>函数 functions</h3>
<h4>内联函数 inline</h4>
<p>程序运行效率,用空间换时间。</p>
<pre><code class="language-cpp">// 使用函数调用
int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = max_function(num1,num2);
    maxv = max_function(numn,maxv);
}
//
float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
//频繁调用max_function
</code></pre>
<p>可以用<code>inline</code>,用空间换时间。</p>
<pre><code class="language-cpp">int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = {   //示意图，没有函数调用，生成的机器代码变多。
    if(num1&gt;num2)
        return num1;
    else
        return num2;}
    maxv = {
    if(numn&gt;maxv)
        return numn;
    else
        return maxv;}
}
// 只会建议编译器执行这样的命令，编译器根据整体情况来判断
inline float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
</code></pre>
<p>使用<code>宏</code>操作</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
//num1 =21,因为num1没有被再次调用
</code></pre>
<h4>默认参数 Default arguments</h4>
<ul>
<li>
<p>默认参数要从尾部开始设
<img width="584" alt="image" src="https://github.com/dululu/notes/assets/64392262/8e579ce4-9d4e-4f55-b2b3-a6548fa949cf"></p>
</li>
<li>
<p>默认参数不能重定义，每个参数只能有一个默认值</p>
</li>
</ul>
<h4>函数重载 overloading</h4>
<p>使用同样的<strong>函数名</strong>，但是做的是不同的事。</p>
<pre><code class="language-cpp">&lt;cmath&gt;
double round(double x);
float round(flaot x);
long duble round(long double x);
</code></pre>
<p><code>cpp</code> 依赖参数列表来查询，选择不同的函数。</p>
<h4>函数模板 templates</h4>
<p>当函数的实现<strong>逻辑</strong>都非常相同的时候，就可以使用函数模板。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
T sum(T x, T y)
{
cout&lt;&lt;&quot;The input type is&quot; &lt;&lt; typeid(T).name &lt;&lt;endl;
return x+y;
}
// 实例化
template double sum(double,double);
template char sum&lt;&gt;(char,char);
template int sum(int,int);
</code></pre>
<h4>函数指针和函数引用 Function pointers and References</h4>
<ul>
<li>函数指针</li>
</ul>
<pre><code class="language-cpp">norm_ptr //指针指向指令区
float norml1(float x, float y);
float norml2(float x, float y);
float (*norm_ptr)(float x, float y);
</code></pre>
<ul>
<li>函数引用</li>
</ul>
<pre><code class="language-cpp">float norml1(float x, float y);
float norml2(float x, float y);
float (&amp;norm_ptr)(float x, float y) = norml1;
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/18"/><category term="Skills"/><category term="cpp"/><published>2024-01-11T06:35:36+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/17</id><title>快速学习C和C++，基础语法和优化策略。（二）</title><updated>2024-01-14T15:22:33.660824+00:00</updated><content type="html"><![CDATA[<h3>P5:结构</h3>
<h4>结构体，联合体，枚举类型</h4>
<ul>
<li><code>struct</code> 定义结构体</li>
</ul>
<pre><code class="language-cpp">struct Student{
    char name[4];
    int born;
    bool male;
};
struct Student stu;
strcpy(stu.name,&quot;X&quot;);
stu.born = 2000;
stu.male = false;

struct Student stu = {&quot;K&quot;,23,true} //初始化，c语言必须要前面的struct
</code></pre>
<p>在c++中class和struct几乎没区别。</p>
<ul>
<li>union
所有成员共享同一个内存，有相同的地址，只是长度不同</li>
</ul>
<img width="265" alt="image" src="https://github.com/dululu/notes/assets/64392262/4c1dd929-7564-49b7-ab0d-d69a232d221e">
<pre><code class="language-cpp">union ipv4address{
    std::unit32_t address32;
    std::unit8_t address[4];
//首地址相同，以最大的对象所占的内存大小为准。
}
</code></pre>
<ul>
<li>enum 枚举</li>
</ul>
<blockquote>
<p>enum make a new type</p>
</blockquote>
<pre><code class="language-cpp">enum color {white,black,blue,red,pink,yellow,num_color}
enum color pen_color = blue;
pen_color = color(3);
</code></pre>
<h4>指针 Pointers</h4>
<pre><code class="language-cpp">&amp; //去变量或对象的地址
* //对指针取内容，取地址里面的那块内容
int *p1 = NULL, *p2 =NULL;
</code></pre>
<ul>
<li><code>p-&gt;member</code></li>
<li><code>(*p).member</code></li>
</ul>
<h4>内存管理 Allocate memory</h4>
<ul>
<li><code>C</code>
<code>Heap</code>:堆，动态申请内存
<code>stack</code>:栈，局部变量，临时变量，<code>int i</code>
堆栈相向而行。
<img width="203" alt="image" src="https://github.com/dululu/notes/assets/64392262/01c6886d-dd60-43f5-ac83-bbed9643be44"></li>
</ul>
<pre><code class="language-cpp">int a = 0;
int b = 0;
int c = 0; 
cout&lt;&lt;&amp;a&lt;&lt;&amp;b&lt;&lt;&amp;c&lt;&lt;endl;

int *p1 = (*int) malloc(4);
int *p2 = (*int) malloc(4);
int *p3 = (*int) malloc(4);
cout&lt;&lt;p1&lt;&lt;p1&lt;&lt;p3&lt;&lt;endl;
</code></pre>
<img width="191" alt="image" src="https://github.com/dululu/notes/assets/64392262/55fba445-8fbd-488d-a938-b707dd77181a">
<blockquote>
<ul>
<li>abc地址越来小，地址连续。</li>
<li>p1p2p3地址越来越大，malloc(4)分配4个字节,9-a-b,每一个差16个字节，但地址是16位对齐,所以剩下的4个字节就浪费掉了。</li>
</ul>
</blockquote>
<ul>
<li>申请内存 Memory allocation</li>
</ul>
<pre><code class="language-cpp">void* malloc(size_t size)
int * p1 =  (int*)malloc(4);//初始化
free（p1）;释放内存
</code></pre>
<ul>
<li><code>c++</code></li>
</ul>
<pre><code class="language-cpp">new//
int *p1 = new int;
int *p2 = new int();
int *p3 = new int(5);
int *p1 = new int{};
//
int *pad = new int[16];
int *p9 = new Student[16];
//释放
delete p1;
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/17"/><category term="Skills"/><category term="cpp"/><published>2024-01-10T17:34:56+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/16</id><title>炒蛋问题</title><updated>2024-01-14T15:22:33.826159+00:00</updated><content type="html"><![CDATA[<p><a href="https://poe.com/ChatGPT">为什么不问一问GPT呢😊😊😊</a></p>
<h3>gdb是啥？</h3>
<ul>
<li>GNU Debugger</li>
</ul>
<blockquote>
<p>gdb是一种由GNU开发的免费的调试器，它可以帮助程序员在开发过程中定位和修复代码中的错误。它提供了一系列命令和功能，可以帮助用户查看程序的内部状态、执行代码步骤、跟踪变量的值等。</p>
</blockquote>
<h3>为啥WSL可以编译cpp</h3>
<blockquote>
<p>WSL是Windows Subsystem for Linux的缩写，它允许Windows用户在其系统上运行Linux环境。因此，通过WSL，用户可以使用Linux上的编译器和工具来编译和运行C++程序。</p>
</blockquote>
<ul>
<li>为了编译C++程序，您还需要安装g++编译器。它是GNU编译器集合中专门用于编译C++程序的工具，可以将源代码编译成可执行文件。在WSL中，您可以通过apt-get命令来安装g++。</li>
<li>可以使用命令“g++ --version”来查看系统中是否已安装g++，以及其版本信息。如果系统中没有安装，您可以通过apt-get命令来安装。
<img width="357" alt="image" src="https://github.com/dululu/notes/assets/64392262/db79ccb8-5c41-478b-b015-d3116528821a"></li>
</ul>
<h3>常见单位换算</h3>
<ul>
<li>1 byte = 8 bit
电脑<strong>存储</strong>的单位有 B（字节）、KB（千字节）、MB（兆字节）、GB（千兆字节）、TB（太字节）和 PB（拍字节）。</li>
<li>
它们之间的换算关系为：<ul>
<li>1 KB = 2 的 10 次方 B，</li>
<li>1 MB = 2 的 20 次方 B，</li>
<li>1 GB = 2 的 30 次方 B，</li>
<li>1 TB = 2 的 40 次方 B，</li>
<li>1 PB = 2 的 50 次方 B。</li>
</ul>
</li>
<li>
通常用来表示<strong>网速</strong>的单位有 bps（每秒比特数）、Kbps（千比特每秒）、Mbps（兆比特每秒）和 Gbps（千兆比特每秒）。它们之间的换算关系为：<ul>
<li>1 Kbps = 2 的 10 次方 bps，</li>
<li>1 Mbps = 2 的 20 次方 bps，</li>
<li>1 Gbps = 2 的 30 次方 bps。</li>
</ul>
</li>
</ul>
<h3>为什么是2^32^B</h3>
<p><a href="https://www.zhihu.com/question/423135323">nice</a>
注意区分<strong>容量</strong>和<strong>长度</strong></p>
<p>说长度的时候就是说这个地址有几个bit</p>
<p>说容量的时候，意思是在这个地址长度下，最多可能存储多少bit</p>
<blockquote>
<ul>
<li>我们可以说一个32位<code>int</code>型变量占的空间为4B，也可以说计算机里面一个32位寄存器可以记录的数据量为4B</li>
<li>32位机时代因为<strong>计算机寄存器</strong>的的容量为32位，那么如果我们只想<strong>用一个寄存器来储存一个内存地址</strong>的话，那么我们最多可以表示2的32次方个不同的内存地址，然后每个内存地址下可以存储1B也就是8bit的信息(<strong>注意不是每个位都有自己的地址)</strong>，所以这种设定下支持的最大内存容量就是2^32B = 2^22KB = 2^12MB = 2^2G = 4G。当然这只是一个上界，有时候内存特殊地址有特殊作用，所以事实上32位Windows支持的最大内存没那么大。</li>
<li>一个地址控制一个字节，所以最终结果是2^32B,计算机中存储器以字节（B）为基本单位。</li>
</ul>
</blockquote>
<h3>++i 和 i++</h3>
<p>两者都是 C++ 中的自增运算符，i++ 表示先使用 i 的值，再对 i 进行加 1 操作，++i 表示先对 i 进行加 1 操作，再使用 i 的值。它们在大多数情况下都可以达到相同的效果，但是在某些特殊情况下会有差异，比如在 for 循环中的使用。</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
</code></pre>
<h4>clang 与 g++</h4>
<p><strong>系统(W/L)-&gt;编译器(clang/g++)-&gt;</strong>
<code>/$</code> 根目录的符号
<code>~$</code> 当前用户的主目录的符号<br />
<code>sudo</code> 是Linux系统中用来获得超级用户权限的命令。使用sudo可以让您以超级用户的身份来运行指定的命令。</p>
<h5>为了在WSL 2中安装Clang，您可以使用WSL提供的apt-get命令来安装。具体的操作步骤如下：</h5>
<ul>
<li>打开WSL 2终端。</li>
<li>运行命令&quot;sudo apt-get update&quot;来更新软件源。</li>
<li>运行命令&quot;sudo apt-get install clang&quot;来安装Clang。</li>
<li>安装完成后，您可以使用命令&quot;clang -v&quot;来验证安装是否成功。</li>
<li><code>clang -std==c++11 1.cpp</code></li>
</ul>
<h4>常用命令</h4>
<h5>文件管理</h5>
<ul>
<li>路径</li>
</ul>
<pre><code class="language-powershell">cd . 当前
cd.. 上一级
cd / 根
cd ~/ 家
</code></pre>
<ul>
<li>文件</li>
</ul>
<pre><code class="language-powershell">madir xxx 创建目录
rm xxx 删除文件 rm xx -r 删除文件夹
mv xxx yy 移动文件/重命名
touch xx 创建文件
cat xx 展示文本
</code></pre>
<ul>
<li>tmux 和 vim
<code>vim-session-pane</code> 平时一般只用一个<code>session</code>，一个<code>session</code>打开多个<code>pane</code></li>
</ul>
<pre><code class="language-powershell">`C+b %` 左右
`C+b “”` 上下
`C+d` 关闭pane
`C+b+d` 挂起session
`tmux+a` 打开挂起的session
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/16"/><category term="question"/><published>2024-01-08T16:56:58+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/15</id><title>快速学习C和C++，基础语法和优化策略（一）</title><updated>2024-01-14T15:22:34.011022+00:00</updated><content type="html"><![CDATA[<p><strong>视频</strong>：<a href="https://www.bilibili.com/video/BV1Vf4y1P7pq/">ysq</a><br />
<strong>文档</strong>: <a href="https://github.com/ShiqiYu/CPP/tree/main/week01">github</a></p>
<blockquote>
<p>只是差缺补漏，快速过一遍💨💨💨</p>
</blockquote>
<ul>
<li>基础知识：以点带面</li>
<li>
本课重点： <strong>指针和内存管理</strong><ul>
<li><strong>程序效率提升；</strong></li>
<li>介绍OpenCV采用c++特性设计cv::Mat类</li>
<li>介绍ARM开发：ARM开发与Intel的x86开发没有区别。嵌入式ARM，智能设备/ARM服务器。</li>
</ul>
</li>
</ul>
<h2>基础知识</h2>
<h3>P1:编译 Compile</h3>
<ul>
<li>编译C++代码：g++编译器</li>
</ul>
<pre><code class="language-cpp">g++ hello.cpp
g++ hello.cpp  --std=c++11  //告诉编译器采用哪一个标准
//执行成功，生成可执行文件a.out
g++ hello.cpp  --std=c++11 -o hello //更改执行文件名
./hello    //执行
</code></pre>
<ul>
<li>
<p>计算机编程语言发展历史</p>
<ul>
<li>
<p>二进制指令（Binary instructions for CPU）: 纸带打孔表示0和1
<img width="292" alt="屏幕截图 2024-01-08 160010" src="https://github.com/dululu/notes/assets/64392262/2732d2af-d738-4ec2-8378-862c4922b39e"></p>
</li>
<li>
<p>汇编语言（assembly language）</p>
</li>
<li>
<p>高级编程语言（high level language）：</p>
<ul>
<li>C:1973  </li>
<li>C++:1979，c with class</li>
<li>Java:1995 生成字节码class文件</li>
<li>Python:1990 脚本语言</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>编译和链接</strong>
<img width="471" alt="屏幕截图 2023-08-06 153029" src="https://github.com/dululu/notes/assets/64392262/8d6d194d-546e-4828-a15d-ec4b475ca8f4"></p>
</li>
<li>
<p>函数的声明和定义(实现)</p>
</li>
</ul>
<pre><code class="language-cpp">
int mul(int a, int b);  //*.h

int mul(int a, int b) // *.c,*.cpp
{
    return a * b;
}
</code></pre>
<ul>
<li>
<strong>debug</strong><ul>
<li>编译错误：语法错误，如漏了分号</li>
<li>链接错误：Mul.o 与 mul.o</li>
<li>运行时错误：如除数为0，2/0  </li>
</ul>
</li>
</ul>
<h3>P2 预处理和宏 Preprocessor and Macros</h3>
<p><em>在编译之前的步骤</em></p>
<ul>
<li>
<p>定义规则</p>
<ul>
<li>以<code>#</code>开头</li>
<li>每个预处理指令只能占一行</li>
</ul>
</li>
<li>
<p>宏定义</p>
</li>
</ul>
<pre><code class="language-cpp">#define PI 3.14 // PI 不是变量，因为不可改变，理解为文字替换
</code></pre>
<ul>
<li>
<strong>为了避免同一个头文件被包含（include）多次，C/C++ 中有两种宏实现方式：</strong><ul>
<li><code>#pragma once</code></li>
</ul>
<pre><code class="language-cpp">  方式一：
  #ifndef __SOMEFILE_H__
  #define __SOMEFILE_H__
  ... ... // 一些声明语句
  #endif

  方式二：
  #pragma once
  ... ... // 一些声明语句,好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题
</code></pre>
<ul>
<li><code> #ifndef / #define</code></li>
</ul>
<pre><code class="language-cpp">  #ifndef __XXX_H__
  #define __XXX_H__
  int a=1;
  #endif    // 如果没有定义宏__XXX_H_,执行；如果已经定义了，直接结束。变量 a 只被定义一次
  //通过宏定义解决头文件重复包含。
</code></pre>
</li>
</ul>
<h3>P3 简单输入和输出</h3>
<h5>cpp</h5>
<ul>
<li>关于<code>std::ostream cout</code>
<em>c++并未定义任何输入输出语句，取而代之，包含了一个全面的<strong>标准库</strong>(std)来提供IO机制。许多例子都是使用<strong>iostream</strong>，来表示输入输出流。</em></li>
<li><strong>ostream</strong> 是一个数据类型，与<code>int</code>,<code>bool</code>类似</li>
</ul>
<blockquote>
<p>cout is an object of data type ostream in namespace std.
cout是命名空间std中数据类型为ostream的对象。
cin 是 istream</p>
</blockquote>
<ul>
<li><code>&lt;&lt;</code>是一个operator运算符</li>
</ul>
<pre><code class="language-cpp">cin &gt;&gt; a; //从标准输入读数据转成整数类型，存到a里面去。
cout &lt;&lt; &quot;打印&quot;;
</code></pre>
<ul>
<li>运算符重载</li>
</ul>
<pre><code class="language-cpp">    data1 + data2;
    operator+(data1,data2);//等价的函数调用
</code></pre>
<h4>c</h4>
<p>c语言风格输出，<code>printf</code></p>
<ul>
<li><code>int printf(const char *format,....)</code></li>
</ul>
<pre><code class="language-cpp">int v = 100;
printf(&quot;Hello,value = %d\n&quot;, v);
</code></pre>
<p>输入:<code>scanf</code></p>
<pre><code class="language-cpp">int v;
int ret = scanf(&quot;%d&quot;,&amp;v);
</code></pre>
<h3>P4 常见数据类型</h3>
<h4><code>int</code></h4>
<img width="437" alt="屏幕截图 2024-01-10 164256" src="https://github.com/dululu/notes/assets/64392262/af10f131-088c-40d8-a5d5-e54a85743779">
<ul>
<li>
<p><code>short int</code> 2个字节16位</p>
</li>
<li>
<p><code>int</code> <strong>一般都是</strong>32位，</p>
<blockquote>
<p>有符号整数<code>int</code></p>
<ul>
<li>max:0111 1111 1111 1111 1111 1111 1111 1111 =2^31^-1</li>
<li>min: 1111 1111 1111 1111 1111 1111 1111 1111 = -2^31^  （多一个负数的最大值）
低31位存数值，最高位存符号</li>
</ul>
</blockquote>
<blockquote>
<p>无符号整数 <code>unsigned int</code></p>
<ul>
<li>max:1111 1111 1111 1111 1111 1111 1111 1111 =2^32^-1</li>
<li>min:0
32位都用来存数值，所以可以存放16位数乘以16位数的数</li>
</ul>
</blockquote>
</li>
</ul>
<img width="457" alt="image" src="https://github.com/dululu/notes/assets/64392262/037b3596-913c-4264-ba8d-c429f260276c">
<h4><code>sizeof()</code>返回当前数值占多少个字节</h4>
<ul>
<li>sizeof不是一个函数，函数的参数必须是<strong>变量</strong>。sizeof(int)是一个操作符。 </li>
</ul>
<pre><code class="language-cpp"> int i = 0;
 cout&lt;&lt;&quot;sizeof(int)=&quot; sizeof(i) &lt;&lt;endl; //i 不是变量，是一个常量。
</code></pre>
<h4><code>char</code></h4>
<ul>
<li><code>char</code>: <strong>8-bit integer indeed!</strong></li>
<li><code>singned char</code>:-128——127</li>
<li><code>unsigned char</code>:0——255</li>
<li>字符本身就是整数，按照编码。<code>ASCII</code>码</li>
</ul>
<blockquote>
<ul>
<li>中文表示
<code>char16_t</code>,<code>char32_t</code></li>
</ul>
</blockquote>
<h4><code>bool</code></h4>
<p>字节是最小的存储单元,<code>bool</code>占一个字节，8位
<code>bool  d = -21</code>;    只要不是<code>0</code>，那么赋值就是<code>1</code></p>
<h4><code>size_t</code></h4>
<p>无符号整数类型，一般表达<strong>内存大小，元素的个数</strong>。</p>
<ul>
<li>返回电脑支持的最大位数</li>
</ul>
<h4>定义一些符号和宏的使用。</h4>
<img width="287" alt="image" src="https://github.com/dululu/notes/assets/64392262/c7e2f322-f4ef-4dcf-bf8d-ade2557a854e">
<h4>浮点数float</h4>
<img width="559" alt="image" src="https://github.com/dululu/notes/assets/64392262/cff54b1e-8955-45f7-8cf3-079ea925b4a2">
<blockquote>
<p>2.34E+10f : 可以表示为 23400000000，即 234 亿。其中，E 表示 10 的指数，+10 表示 10 的 10 次方，f 表示浮点数。</p>
</blockquote>
<ul>
<li>
32位单精度浮点数<ul>
<li>符号位</li>
<li>系数</li>
<li>精度</li>
</ul>
</li>
<li>double,64位</li>
<li>long double</li>
</ul>
<h4>数组 array[]</h4>
<blockquote>
<ul>
<li>连续的内存,在Java中是一个对象。</li>
<li>可以是存储任何数据类型</li>
</ul>
</blockquote>
<ul>
<li>未知长度的数组，长度由初始化决定。</li>
</ul>
<pre><code class="language-cpp">int num_array[] = {1,3,4,6};// 4 int
</code></pre>
<ul>
<li>把数组传递给函数内部。</li>
</ul>
<blockquote>
<p>values[]是一个指针，代表数组的<strong>首地址</strong>，size_t数组&gt;的长度。</p>
</blockquote>
<pre><code class="language-cpp">//float类型的指针
float array_sum(values[], size_t length);
float array_sum(*values, size_t length);
</code></pre>
<ul>
<li>
<p>数组元素的读写
<code>array1</code>,<code>array2</code>是数组的首地址
<img width="292" alt="image" src="https://github.com/dululu/notes/assets/64392262/da539a3d-efed-44b4-95aa-c26c888dd164"></p>
</li>
<li>
<p>越界</p>
<blockquote>
<p>没有边界检查，在c++中。如果发生越界，按照地址的逻辑直接去进行读和写。</p>
</blockquote>
<ul>
<li>在c++中，数组不是一个对象；<strong>数组是一块连续的内存，数组名指向首地址 ，大小不知道。</strong></li>
<li>缺点：易出错    优点：没有边界检查，效率高</li>
</ul>
</li>
<li>
<p>多维数组
当使用数组名作为<strong>首地址</strong>的时候，必须指定<strong>列</strong>数，不然找不到下一行。 确定偏移的位置。</p>
</li>
</ul>
<img width="563" alt="image" src="https://github.com/dululu/notes/assets/64392262/8f5af34b-a194-4d27-a171-f82da1bf7e79">
<img width="290" alt="image" src="https://github.com/dululu/notes/assets/64392262/382c76d0-1289-4181-adc4-cf52e6bca811">
<h4>字符串 String</h4>
<ul>
<li>
<p>Array-style Strings <strong>数组类型字符串</strong>
最后<strong>一定要加一个0</strong>，来结束字符串。<strong>'\0'</strong> 整数值为0，字符到此为止。否则就会发生越界。
<img width="568" alt="image" src="https://github.com/dululu/notes/assets/64392262/30e4e031-d80d-43fc-b532-3abf3e9ad28d"></p>
</li>
<li>
<p>strlen()返回字符的<strong>数量</strong>,遇到‘\0’就会终止。</p>
</li>
</ul>
<pre><code class="language-cpp">    size_t strlen(const char *str);
</code></pre>
<ul>
<li>常见的字符串</li>
</ul>
<img width="614" alt="image" src="https://github.com/dululu/notes/assets/64392262/549305e1-1c62-4250-a38b-c6d952790231">
<img width="603" alt="image" src="https://github.com/dululu/notes/assets/64392262/374d10eb-3abd-4c60-8d97-bdfdc377b07b">
<p><strong>数组长度为5，字符串长度为4</strong></p>
<ul>
<li>String class
string可以<strong>直接使用运算符</strong>对字符串进行操作。string类没有越界检查
<img width="617" alt="image" src="https://github.com/dululu/notes/assets/64392262/3cb6200f-588d-4207-b89f-0d2c5c2f4988"></li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/15"/><category term="Skills"/><category term="cpp"/><published>2024-01-08T05:46:40+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/13</id><title>自省</title><updated>2024-01-14T15:22:34.200132+00:00</updated><content type="html"><![CDATA[<ul>
<li>早睡早起</li>
<li>不要浪费时间</li>
</ul>
<blockquote>
<p>[!NOTE]<br />
Highlights information that users should take into account, even when skimming.</p>
</blockquote>
<blockquote>
<p>[!TIP]
Optional information to help a user be more successful.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]<br />
Crucial information necessary for users to succeed.</p>
</blockquote>
<blockquote>
<p>[!WARNING]<br />
Critical content demanding immediate user attention due to potential risks.</p>
</blockquote>
<blockquote>
<p>[!CAUTION]
Negative potential consequences of an action.</p>
</blockquote>
]]></content><link href="https://github.com/dululu/notes/issues/13"/><category term="文章"/><published>2024-01-06T18:45:11+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/11</id><title>2024</title><updated>2024-01-14T15:22:34.367263+00:00</updated><content type="html"><![CDATA[<p><a href="https://github.com/yihong0618/2020?tab=readme-ov-file">yihong2022</a></p>
]]></content><link href="https://github.com/dululu/notes/issues/11"/><category term="收藏文章"/><published>2024-01-06T18:04:47+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/10</id><title>高效学习方法</title><updated>2024-01-14T15:22:34.543916+00:00</updated><content type="html"><![CDATA[<p>mark</p>
]]></content><link href="https://github.com/dululu/notes/issues/10"/><category term="文章"/><published>2024-01-06T17:48:01+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/9</id><title>需要学习的东西</title><updated>2024-01-14T15:22:34.729777+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> q</li>
<li><input disabled="" type="checkbox"> e</li>
<li><input disabled="" type="checkbox"> r</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/9"/><category term="TODO"/><published>2024-01-06T16:54:19+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/7</id><title>链接</title><updated>2024-01-14T15:22:34.889887+00:00</updated><content type="html"><![CDATA[<p>格式如下（请参考我下面的 comment）:
冒号为中文冒号 ：</p>
<p>名字：xxxxxx
链接：xxxxxx
描述：xxxxxx</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> added
打心后会自动加到友情链接里。</li>
</ul>
<p>❤</p>
]]></content><link href="https://github.com/dululu/notes/issues/7"/><category term="Friends"/><published>2024-01-06T15:30:06+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/3</id><title>Gitblog</title><updated>2024-01-14T15:22:35.059980+00:00</updated><content type="html"><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox">  <a href="#1">rss，todolist , 友情链接，置顶文章</a> </li>
<li><input disabled="" type="checkbox"> 扇贝单词，读书&amp;刷剧区<a href="https://github.com/yihong0618/2022/tree/main/daily">主要代码</a></li>
<li><input disabled="" type="checkbox">  GitHub Action</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/3"/><category term="TODO"/><published>2024-01-04T19:44:07+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/2</id><title>GitHubActions</title><updated>2024-01-14T15:22:35.230224+00:00</updated><content type="html"><![CDATA[<p>mark</p>
]]></content><link href="https://github.com/dululu/notes/issues/2"/><category term="Skills"/><published>2024-01-04T17:29:14+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/1</id><title>博客页面</title><updated>2024-01-14T15:22:35.392572+00:00</updated><content type="html"><![CDATA[<h2><a href="https://laike9m.com/blog/people-die-but-long-live-github,122/">People Die, but Long Live GitHub</a></h2>
<ul>
<li>参考来源：<a href="https://github.com/yihong0618/gitblog/issues/209">yihong</a>&amp;<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a></li>
<li>
具体方法：<ul>
<li>将.github文件夹，main.py,requirments.txt复制到需要的文件夹下</li>
<li>生成github secret token,在yml文件中改成自己的</li>
<li>将yihong的readme文件复制过来，提交一个issue，创建一个label</li>
<li>刷新GitHub</li>
</ul>
</li>
<li>可以创建属于自己的分区</li>
</ul>
<blockquote>
<ul>
<li><strong>rss</strong> 将仓库名改为自己的仓库名,原始为gitblog,根目录下创建一个feed.xml文件</li>
<li><strong>友情链接</strong> 创建一个标签为<code>Friend</code>的<code>issue</code>,按照格就可自动添加，点上红心❤自动添加。<a href="https://github.com/yihong0618/gitblog/issues/217">详情</a></li>
<li><strong>todolist</strong> 创建一个标签为<code>TODO</code>的<code>issue</code>,注意issue的格式，<code>*</code>不可以，<code>-</code>可以正常显示。</li>
</ul>
</blockquote>
<p><em>跟据<code>label</code>和<code>comment</code>更改</em></p>
<pre><code>COOK_LABEL_LIST = [
    &quot;Cook&quot;,
]
MOVIE_LABEL_LIST = [
    &quot;Movie&quot;,
]
READ_LABEL_LIST = [
    &quot;Read&quot;,
]
DRAMA_LABEL_LIST = [
    &quot;Drama&quot;,
]
PUSHUP_LABEL_LIST = [
    &quot;PushUps&quot;,
]
BANGUMI_LABEL_LIST = [
    &quot;Bangumi&quot;,
]
GAME_LABEL_LIST = [
    &quot;Game&quot;,
]
MONEY_LABEL_LIST = [
    &quot;Money&quot;,
]
MEDITATION_LABEL_LIST = [
    &quot;Meditation&quot;,
]
MORNING_LABEL_LIST = [
    &quot;Morning&quot;,
]
GTD_LABEL_LIST = [
    &quot;GTD&quot;,
]
MY_BLOG_REPO = &quot;yihong0618/gitblog&quot;
GITHUB_README_COMMENTS = (
    &quot;(&lt;!--START_SECTION:{name}--&gt;\n)(.*)(&lt;!--END_SECTION:{name}--&gt;\n)&quot;
)

# add new label here
LABEL_DICT = {
    &quot;Cook&quot;: {&quot;label_list&quot;: COOK_LABEL_LIST, &quot;comment_name&quot;: &quot;my_cook&quot;},
    &quot;Movie&quot;: {&quot;label_list&quot;: MOVIE_LABEL_LIST, &quot;comment_name&quot;: &quot;my_movie&quot;},
    &quot;Read&quot;: {&quot;label_list&quot;: READ_LABEL_LIST, &quot;comment_name&quot;: &quot;my_read&quot;},
    &quot;Drama&quot;: {&quot;label_list&quot;: DRAMA_LABEL_LIST, &quot;comment_name&quot;: &quot;my_drama&quot;},
    &quot;Bangumi&quot;: {&quot;label_list&quot;: BANGUMI_LABEL_LIST, &quot;comment_name&quot;: &quot;my_bangumi&quot;},
    &quot;Game&quot;: {&quot;label_list&quot;: GAME_LABEL_LIST, &quot;comment_name&quot;: &quot;my_game&quot;},
}


##### SHANBAY ######
MY_SHANBAY_USER_NAME = &quot;ufewz&quot;
SHANBAY_CALENDAR_API = &quot;https://apiv3.shanbay.com/uc/checkin/calendar/dates/?user_id={user_name}&amp;start_date={start_date}&amp;end_date={end_date}&quot;
MY_SHANBAY_URL = f&quot;https://web.shanbay.com/web/users/{MY_SHANBAY_USER_NAME}/zone&quot;

##### DUO ######
MY_DUOLINGO_URL = &quot;https://www.duolingo.com/profile/yihong0618&quot;

##### CICHANG ######
MY_CICHANG_URL = &quot;https://twitter.com/yihong06181/status/1359040099107897344?s=20&quot;


##### FOOD ######
MY_FOOD_STAT_HEAD = (
    &quot;| Name | First_date | Last_date | Times | \n | ---- | ---- | ---- | ---- |\n&quot;
)
MY_FOOD_STAT_TEMPLATE = &quot;| {name} | {first_date} | {last_date} | {times} |\n&quot;

##### Month Summary ######
MONTH_SUMMARY_HEAD = &quot;| Month | Number | \n | ---- | ---- | \n&quot;

MONTH_SUMMARY_STAT_TEMPLATE = &quot;| {month} | {number} |\n&quot;
</code></pre>
<p>✍️</p>
]]></content><link href="https://github.com/dululu/notes/issues/1"/><category term="Skills"/><category term="Top"/><published>2024-01-03T18:37:05+00:00</published></entry></feed>