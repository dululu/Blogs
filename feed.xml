<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/dululu/notes</id><title>RSS feed of dululu's notes</title><updated>2024-03-30T15:05:08.744487+00:00</updated><link href="https://github.com/dululu/notes"/><link href="https://raw.githubusercontent.com/dululu/notes/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="1.0.0">python-feedgen</generator><entry><id>https://github.com/dululu/notes/issues/38</id><title> urllib3</title><updated>2024-03-30T15:05:08.968110+00:00</updated><content type="html"><![CDATA[<p><code>urllib3</code>是一个<code>Python</code>的第三方库，用于在<code>HTTP</code>请求中处理连接池、编码、重试等功能。它提供了一个高级的<code>HTTP</code>客户端接口，简化了与Web服务器进行通信的过程。</p>
<ul>
<li>使用<code>urllib3</code>库可以进行<code>HTTP</code>请求的发送和处理。可以创建<code>PoolManager</code>对象来管理连接池，并使用该对象发送<code>GET</code>、<code>POST</code>等类型的请求。<code>urllib3</code>提供了对请求和响应的各种处理方法，例如设置请求头部、处理响应内容等。</li>
</ul>
<h5>以下是一个使用urllib3发送GET请求的简单示例：</h5>
<pre><code class="language-python">import urllib3
# 创建连接池管理器
http = urllib3.PoolManager()
# 发送GET请求
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;)
# 获取响应内容
data = response.data
# 打印响应内容
print(data.decode(&#x27;utf-8&#x27;))
</code></pre>
<blockquote>
<p>首先创建了一个<code>PoolManager</code>对象，然后使用该对象发送<code>GET</code>请求，请求的目标<code>URL</code>是<code>http://www.example.com</code>。最后，通过<code>response.data</code>获取响应的内容，并将其解码为字符串后打印出来。</p>
</blockquote>
<h4>HEAD请求和GET请求在HTTP协议中是两种不同的请求方法，</h4>
<ul>
<li>返回内容：<code>GET</code>请求会返回请求的资源内容，包括响应头部和响应体。而<code>HEAD</code>请求只返回响应头部，不返回响应体内容。因此，HEAD请求可以用于仅获取资源的元数据或检查资源是否存在，而不需要获取实际内容。</li>
</ul>
<hr />
<h3>更灵活地处理请求和响应。</h3>
<ul>
<li><strong>自定义请求头部</strong>：您可以通过在请求时传递headers参数来设置自定义的请求头部。例如：</li>
</ul>
<pre><code class="language-python">headers = {
    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36&#x27;,
    &#x27;Authorization&#x27;: &#x27;Bearer your_token_here&#x27;
}
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;, headers=headers)
</code></pre>
<p>在上面的示例中，我们定义了一个<strong>字典</strong><code>headers</code>，包含了自定义的请求头部信息，并将其作为<code>headers</code>参数传递给请求方法。</p>
<ul>
<li><strong>处理请求参数</strong>：如果需要在GET请求中传递查询参数，可以<strong>使用fields参数将参数以字典形式传递给请求方法</strong>。例如：</li>
</ul>
<pre><code class="language-python">params = {
    &#x27;key1&#x27;: &#x27;value1&#x27;,
    &#x27;key2&#x27;: &#x27;value2&#x27;
}
response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;, fields=params)
</code></pre>
<p>在上面的示例中，我们定义了一个字典<code>params</code>，包含了查询参数的键值对，并将其作为<code>fields</code>参数传递给GET请求方法。</p>
<ul>
<li><strong>处理POST请求数据</strong>：对于POST请求，可以使用<code>body</code>参数或<code>fields</code>参数来传递请求数据。如果需要<strong>发送<code>JSON</code>格式的数据</strong>，可以使用<code>json</code>参数。例如：</li>
</ul>
<pre><code class="language-python">import json

data = {
    &#x27;name&#x27;: &#x27;John Doe&#x27;,
    &#x27;age&#x27;: 30
}
encoded_data = json.dumps(data).encode(&#x27;utf-8&#x27;)

response = http.request(&#x27;POST&#x27;, &#x27;http://www.example.com&#x27;, body=encoded_data, headers={&#x27;Content-Type&#x27;: &#x27;application/json&#x27;})
</code></pre>
<p>在上面的示例中，我们将数据编码为<code>JSON</code>格式并将其作为body参数传递给<code>POST</code>请求方法。还设置了请求头部中的<code>Content-Type为application/json</code>，指示服务器接收<code>JSON</code>格式的数据。</p>
<ul>
<li><strong>处理响应</strong>：<code>urllib3</code>的响应对象提供了许多属性和方法来处理响应数据。例如，可以使用<code>response.status</code>获取响应的状态码，<code>response.headers</code>获取响应头部信息，<code>response.data</code>获取响应的内容等。</li>
</ul>
<pre><code class="language-python">response = http.request(&#x27;GET&#x27;, &#x27;http://www.example.com&#x27;)
status_code = response.status
headers = response.headers
data = response.data
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/38"/><category term="Python"/><published>2024-03-30T06:13:17+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/37</id><title> HTTP/1.1 </title><updated>2024-03-30T15:05:09.059996+00:00</updated><content type="html"><![CDATA[<p>当客户端使用HTTP/1.1与服务器进行通信时，以下是一个简单的示例：</p>
<pre><code>GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml
</code></pre>
<p><strong>客户端</strong>发送一个<code>GET</code>请求，请求获取位于<strong>服务器</strong>上的index.html文件。请求中使用了<strong>HTTP/1.1</strong>版本。
请求头部包含了一些额外的信息：</p>
<ul>
<li><code>Host</code>头部指定了<strong>服务器</strong>的域名（[www.example.com），这是HTTP/1.1中引入的一个必需的头部。</li>
<li><code>User-Agent</code>头部指定了<strong>客户端的用户代理</strong>，即浏览器的身份信息。</li>
<li><code>Accept</code>头部指定了<strong>客户端</strong>可以接受的响应内容类型，这里指定可以接受<code>HTML</code>和<code>XHTML</code>类型的内容。</li>
</ul>
<hr />
<h4>当客户端使用HTTP/1.1进行<code>POST</code>请求时，以下是一个简单的示例：</h4>
<pre><code>POST /submit-form HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 25

username=johndoe&amp;password=123
</code></pre>
<p><strong>客户端</strong>发送了一个<code>POST</code>请求，将表单数据提交到服务器上的<code>/submit-form</code>路径。</p>
<blockquote>
<p>与GET请求相比，<code>POST</code>请求通常用于向服务器提交数据，如表单数据。</p>
</blockquote>
<p>请求头部包含了一些额外的信息：</p>
<ul>
<li><code>Host</code>头部指定了服务器的域名</li>
<li><code>Content-Type</code>头部指定了请求体的媒体类型为<code>application/x-www-form-urlencoded</code>，表示表单数据将使用<code>URL</code>编码格式进行传输。</li>
<li><code>Content-Length</code>头部指定了请求体的长度，这里是25个字节。</li>
</ul>
<h2>POST请求和GET请求是HTTP协议中两种常见的请求方法，它们在以下几个方面有着明显的区别：</h2>
<ul>
<li>数据传输位置：GET请求通过URL的查询参数将数据<strong>附加在请求URL的末尾，而POST请求将数据包含在请求的主体中</strong>。因此，GET请求的数据在URL中是可见的，而POST请求的数据对于普通用户来说是不可见的。</li>
<li>安全性：由于GET请求将数据<strong>暴露在URL</strong>中，数据容易被拦截、篡改或缓存。相比之下，POST请求将数据放在请求主体中，对于一些敏感信息（如密码）的传输更为安全。</li>
<li>数据长度限制：GET请求的<strong>数据传输受到URL长度限制的影响</strong>，不同的浏览器和服务器有不同的限制值，通常在几千个字符左右。而POST请求的数据传输没有固定的长度限制，但服务器和应用程序可能会设置自己的限制。</li>
<li>数据类型：G<strong>ET请求通常用于获取资源或从服务器获取数据，而POST请求通常用于向服务器提交数据</strong>，例如表单提交、文件上传等。POST请求允许发送更多类型的数据，而GET请求主要适用于发送简单的键值对数据。</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/37"/><category term="Python"/><published>2024-03-30T05:30:25+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/36</id><title>Requests: HTTP for Humans™</title><updated>2024-03-30T15:05:09.178387+00:00</updated><content type="html"><![CDATA[<h2><a href="https://requests.readthedocs.io/en/latest/">Requests</a></h2>
<ul>
<li><a href="https://github.com/dululu/notes/issues/37">HTTP/1.1</a></li>
<li><a href="https://github.com/dululu/notes/issues/38">urllib3</a></li>
<li><a href="https://github.com/dululu/notes/issues/38">JSON</a></li>
<li><a href="https://github.com/dululu/notes/issues/34">Status Codes¶</a></li>
</ul>
<hr />
<h3>Quickstart<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#quickstart">¶</a></h3>
<ul>
<li>Response Content</li>
<li>Binary Response Content</li>
<li>JSON Response Content</li>
<li>Custom Headers</li>
<li>More complicated POST requests<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#more-complicated-post-requests">¶</a></li>
<li>POST a Multipart-Encoded File<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#post-a-multipart-encoded-file">¶</a></li>
<li>Response Status Codes<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#response-status-codes">¶</a></li>
<li>Response Headers<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#response-headers">¶</a>
We can view the server’s response headers using a Python dictionary:
<strong>HTTP Header names are case-insensitive.</strong> </li>
</ul>
<pre><code class="language-python">import requests
r = requests.get(&#x27;https://httpbin.org/get&#x27;)
r.status_code
print(r.status_code)
print(r.headers)

r.headers[&#x27;Content-Type&#x27;]
&#x27;application/json&#x27;

r.headers.get(&#x27;content-type&#x27;)
&#x27;application/json&#x27;
</code></pre>
<ul>
<li>Cookies<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#cookies">¶</a>
If a response contains some Cookies, you can quickly access them,Cookies are returned in a <a href="https://requests.readthedocs.io/en/latest/api/#requests.cookies.RequestsCookieJar">RequestsCookieJar</a>, which acts like a dict but also offers a more complete interface, suitable for use over multiple domains or paths. Cookie jars can also be passed in to requests:</li>
<li>Redirection and History<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#redirection-and-history">¶</a></li>
<li>Timeouts<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#timeouts">¶</a>
You can tell Requests to stop waiting for a response after a given number of seconds with the <code>timeout</code> parameter.</li>
<li>Errors and Exceptions<a href="https://requests.readthedocs.io/en/latest/user/quickstart/#errors-and-exceptions">¶</a></li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/36"/><category term="Python"/><published>2024-03-30T05:05:15+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/34</id><title>Status Codes¶</title><updated>2024-03-30T15:05:09.279379+00:00</updated><content type="html"><![CDATA[<p>HTTP状态码（Status Codes）是在HTTP协议中用于表示请求的处理结果的三位数代码。每个状态码都具有特定的含义，用于指示请求是否成功、遇到错误、需要进一步操作等。
以下是一些常见的HTTP状态码及其含义：</p>
<ul>
<li>200 OK：请求成功。服务器成功处理了请求并返回所需的内容。</li>
<li>201 Created：已创建。请求成功，并在服务器上创建了新的资源。</li>
<li>204 No Content：无内容。请求成功，但响应不包含任何内容。</li>
<li>400 Bad Request：错误的请求。服务器无法理解或处理请求，通常是由于请求语法错误。</li>
<li>401 Unauthorized：未授权。请求需要身份验证，但未提供有效的身份凭据。</li>
<li><code>403 Forbidden</code>：禁止访问。服务器拒绝请求，因为请求的资源禁止访问。</li>
<li><code>404 Not Found</code>：未找到。请求的资源在服务器上不存在。</li>
<li><code>500 Internal Server Error</code>：服务器内部错误。服务器在处理请求时遇到意外错误。</li>
</ul>
<blockquote>
<p>4XX client error or 5XX server error response</p>
</blockquote>
<hr />
<pre><code class="language-python">import requests
r = requests.get(&#x27;https://httpbin.org/get&#x27;)
r.status_code
print(r.status_code)
</code></pre>
<ul>
<li>If we made a bad request (a 4XX client error or 5XX server error response), we can raise it with <a href="https://requests.readthedocs.io/en/latest/api/#requests.Response.raise_for_status">Response.raise_for_status()</a>:</li>
</ul>
<pre><code class="language-python">bad_r = requests.get(&#x27;https://httpbin.org/status/404&#x27;)
bad_r.status_code
404

bad_r.raise_for_status()
Traceback (most recent call last):
  File &quot;requests/models.py&quot;, line 832, in raise_for_status
    raise http_error
requests.exceptions.HTTPError: 404 Client Error
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/34"/><category term="Python"/><published>2024-03-08T19:53:42+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/33</id><title>问题汇总3</title><updated>2024-03-30T15:05:09.391798+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> 相对路径和绝对路径</li>
</ul>
<p><strong><em>路径</em></strong></p>
<ul>
<li><strong>绝对路径</strong>是指从文件系统的根目录开始一直到目标文件或目录的完整路径。如<code>C:\Users\Username\Documents\File.txt</code>是一个<strong>Windows</strong>系统下的绝对路径。<em>在类Unix系统（如<strong>Linux和macOS</strong>）中</em>，绝对路径以斜杠（/）开始，然后按照目录结构一级一级地指定目标位置。例如，<code>/home/username/Documents/file.txt</code>是一个Linux系统下的绝对路径。</li>
<li>相对路径是相对于当前工作目录或当前所在位置的路径。它不需要提供完整的路径，而是根据当前位置和目标位置之间的相对位置来指定。相对路径可以使用特殊符号来表示路径关系。在Windows系统中，两个常用的特殊符号是&quot;..&quot;和&quot;.&quot;。&quot;..&quot;表示上一级目录，&quot;.&quot;表示当前目录。例如，假设当前工作目录是<code>C:\Users\Username</code>，要指向文件<code>C:\Users\Username\Documents\File.txt</code>，可以使用相对路径<code>..\Documents\File.txt</code>。</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/33"/><category term="疑问🤔"/><published>2024-03-08T07:57:24+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/32</id><title> 计算机中，数据可以使用不同的编码方式进行保存和表示</title><updated>2024-03-30T15:05:09.490463+00:00</updated><content type="html"><![CDATA[<h3>关于<code>char</code>和<code>int</code></h3>
<ul>
<li>
众所周知在c++中<code>char</code>占一个字节，8位；<code>int</code>占4个字节，32位；
在计算机中数据最终是通过<strong>二进制编码</strong>保存。而<strong>字符编码</strong>用于将字符映射到二进制数据。
常见的字符编码：<ul>
<li>ASCII（美国标准码）</li>
</ul>
</li>
</ul>
<img width="328" alt="image" src="https://github.com/dululu/notes/assets/64392262/2caf88c7-a146-40cf-937a-3c8a2fc9ba3b">
<p>使用<code>ASCII字符</code>代表26个字母大小写，还有0~9的字符。所以最终本质都是<code>二进制</code>编码，因为只有占一个字节，只能从0—255。</p>
<blockquote>
<p>还有Unicode 和 UTF-8（一种可变长度的 Unicode 编码）</p>
</blockquote>
]]></content><link href="https://github.com/dululu/notes/issues/32"/><category term="cpp"/><published>2024-03-07T12:33:39+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/31</id><title>AI TOOL</title><updated>2024-03-30T15:05:09.592705+00:00</updated><content type="html"><![CDATA[<ul>
<li><a href="https://poe.com/chat/230btdq08a1544w930h">poe</a></li>
</ul>
<blockquote>
<p>集成gpt,就是有点卡</p>
</blockquote>
<ul>
<li><a href="https://devv.ai/">Devv</a></li>
</ul>
<blockquote>
<p>代码专用，一步一步挺好的</p>
</blockquote>
<ul>
<li><a href="https://www.perplexity.ai/">perplexity</a></li>
</ul>
<blockquote>
<p>还行，可以交互</p>
</blockquote>
<p>网络代理问题：
1.https://doc.miyun.app/
2.规则代理，换路线。
3.清理DNS缓存</p>
]]></content><link href="https://github.com/dululu/notes/issues/31"/><category term="Top"/><published>2024-03-06T22:06:29+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/30</id><title>git使用</title><updated>2024-03-30T15:05:09.730858+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>原则上是碰到问题再用</p>
</blockquote>
<ol>
<li>删除GitHub文件</li>
<li><code>.gitignore</code></li>
<li><code>stage</code></li>
<li><code>pull</code>和<code>push</code>使用</li>
<li><code>ssh key</code>使用</li>
<li><code>Personal access tokens (classic)</code>个人访问令牌</li>
</ol>
<ul>
<li>
<input checked="" disabled="" type="checkbox"> 如何在本地删除传到GitHub的文件<ul>
<li>首先进入文件仓库</li>
<li>如果想要本地和GitHub一起删除<code>git rm file</code>,只是删除云端<code>git rm --cached file</code></li>
<li><code>git commit -m &quot;delete a file&quot;</code>和<code>git push origin main</code></li>
</ul>
</li>
</ul>
<p>⚠️如果删除单个文件直接删，删除文件夹<code>git rm file -r</code></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>.gitignore</code>
使用斜杠（/）指定目录或文件夹。
使用星号（*）表示通配符，匹配零个或多个字符。
使用问号（?）表示通配符，匹配一个字符。
使用感叹号（!）表示取反，即不忽略该模式匹配到的内容。
使用井号（#）表示注释，该行后面的内容将被忽略。</li>
</ul>
<pre><code># 忽略编译生成的文件
*.o
*.exe
# 忽略目录
/build/
/dist/
# 不忽略特定文件
!src/main.c
</code></pre>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>stage</code>
在Git中，&quot;stage&quot;是指将文件或更改添加到暂存区（也称为索引）的过程。暂存区是位于Git仓库中的一个中间区域，用于准备将要提交的更改。
当您对文件进行修改后，可以使用<code>git add .</code>命令将更改添加到暂存区.</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/30"/><category term="Skills"/><category term="Git"/><published>2024-03-06T20:35:39+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/29</id><title>一些常用函数</title><updated>2024-03-30T15:05:09.822301+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> <code>strcpy</code>函数</li>
<li><input disabled="" type="checkbox"> <code>memset</code>函数</li>
<li><input disabled="" type="checkbox"> <code>atoi</code>函数</li>
<li><input disabled="" type="checkbox"> <code>sizeof()</code>运算符</li>
</ul>
<ol>
<li><code>strcpy</code>
strcpy 是一个常见的 C 语言字符串操作函数，用于将一个字符串复制到另一个字符串中。
函数原型如下：</li>
</ol>
<pre><code class="language-c++">char* strcpy(char* destination, const char* source);
</code></pre>
<p>2.<code>memset</code>
memset 是一个 C 语言中的函数，用于将一块内存区域的每个字节设置为指定的值。</p>
<pre><code class="language-c++">void* memset(void* ptr, int value, size_t num);
memset(str, &#x27;A&#x27;, 10); // 将 str 的前 10 个字节设置为 &#x27;A&#x27;
</code></pre>
<p>memset 函数通常用于初始化内存区域或将内存区域清零。</p>
<p>3.<code>atoi</code>
atoi 是一个 C 语言中的函数，用于将字符串转换为整数（integer）。
函数原型如下</p>
<pre><code class="language-cpp">int atoi(const char* str);
</code></pre>
<p>它会忽略字符串开头的空白字符，直到找到第一个非空白字符。然后，从该字符开始解析连续的数字字符，直到遇到非数字字符为止。它将解析得到的数字字符序列转换为整数并返回。
4.<code>sizeof()</code>
用于计算数据类型或变量的字节大小。
type 是一个数据类型，如 <code>int</code>、<code>float</code>、<code>char</code> 等，或者是一个具体的变量、数组、结构体等表达式。
函数的参数必须是_变量_。<code>int</code>是操作符</p>
]]></content><link href="https://github.com/dululu/notes/issues/29"/><category term="cpp"/><published>2024-03-05T14:48:25+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/28</id><title>EnglishWords</title><updated>2024-03-30T15:05:09.904824+00:00</updated><content type="html"><![CDATA[<h4><a href="https://translate.google.com.hk/?hl=zh-CN">谷歌翻译</a></h4>
<h3><a href="https://dictionary.cambridge.org/zhs/%E8%AF%8D%E5%85%B8/%E8%8B%B1%E8%AF%AD-%E6%B1%89%E8%AF%AD-%E7%AE%80%E4%BD%93/backup">剑桥翻译</a></h3>
<p><strong><em>From where ?</em></strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Obsdian</li>
<li><input checked="" disabled="" type="checkbox"> Github</li>
<li><input checked="" disabled="" type="checkbox"> 常见</li>
</ul>
<h2><strong>obsdian</strong></h2>
<ul>
<li>interval       间隔，间距</li>
<li>vault           保险库，金库</li>
<li>backup       备份，替补，伴奏</li>
<li>millisecond 毫秒</li>
<li>miscellaneous 杂项，冗杂</li>
<li>submodules 子模块/组</li>
</ul>
<h2><strong>Github</strong></h2>
<ul>
<li>fatal           致命的，有害的，命中注定的</li>
<li>permanently  永久地，永恒地</li>
</ul>
<h2><strong>常见</strong></h2>
<ul>
<li>argument/arg  争论，论据/变元，自变量</li>
<li>parameter 参数</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/28"/><category term="English"/><published>2024-03-05T11:54:32+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/27</id><title>面向连接和面向消息的套接字</title><updated>2024-03-30T15:05:10.021565+00:00</updated><content type="html"><![CDATA[<p>面向连接的套接字：stream</p>
<ul>
<li>收发数据的套接字内有缓冲（buffer）,就是字节数组。不存在数据边界</li>
<li>缓冲可能·被填满，套接字无法再接收数据，传输套接字停止传输。</li>
<li>根据接收端状态传输数据。</li>
<li>套接字必须一一对应。</li>
<li>可靠的，按顺序传递的，基于<strong>字节</strong>的，面向连接的。</li>
</ul>
<p>面向消息的：</p>
<ul>
<li>更快的速度，无法避免数据丢失或损毁。</li>
<li>存在数据边界，传输的数据大小有限制。</li>
<li>接受数据的次数应该和传输数据的次数<strong>相同</strong>。</li>
<li>不存在<strong>连接</strong>的概念。</li>
<li>不可靠的，不按顺序的，数据高速传输为目的。</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/27"/><published>2024-03-03T19:26:57+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/26</id><title>问题汇总2</title><updated>2024-03-30T15:05:10.120472+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>list2</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 关于代理</li>
<li><input checked="" disabled="" type="checkbox"> 代码中的<code>0</code></li>
<li><input checked="" disabled="" type="checkbox"> 关于<code>.gitignore</code></li>
<li><input checked="" disabled="" type="checkbox"> <code>pull request</code></li>
</ul>
<h3>系统代理</h3>
<p>系统代理是一种在操作系统级别设置的代理配置，它会影响整个计算机上的所有网络连接。通过配置系统代理，您可以将所有网络流量通过代理服务器进行转发，以实现对网络流量的控制和管理。</p>
<blockquote>
<p>在示意图中，我们将使用三个要素来表示系统代理的设置：
操作系统设置：这是您的计算机操作系统的网络设置界面。
代理服务器地址和端口：这是代理服务器的网络地址和端口号。
代理类型：这表示您可以选择的不同代理类型，例如HTTP代理、SOCKS代理等。</p>
</blockquote>
<ul>
<li>
<blockquote>
<p>代理服务器的地址为 127.0.0.1，端口号为 7897。请注意，127.0.0.1 是本地回环地址，通常用于指向本机的网络接口。端口号 7897 是代理服务器<strong>监听</strong>的网络端口。</p>
</blockquote>
</li>
<li>TUN（全称为网络隧道）模式是一种在计算机网络中使用的网络设备驱动程序模式。它可以在操作系统级别创建虚拟网络接口，将网络数据包封装在其他协议中进行传输。</li>
<li>局域网内共享代理：在局域网中连接Clash代理服务器后，其他设备也可以通过相同的代理进行网络连接。这意味着您可以在整个局域网中共享代理服务，使所有设备都能享受到相同的优势和功能。</li>
<li><strong>全局和规则</strong></li>
</ul>
<h4><strong>全局代理（Global Proxy）模式</strong>：</h4>
<p>全局代理模式是将所有的网络流量都通过代理服务器进行转发的模式。在全局代理模式下，所有的网络请求都会经过代理服务器，无论是浏览器、应用程序还是系统级别的请求。这意味着所有的网络流量都会通过代理服务器进行转发，无论目的地是什么。全局代理模式通常用于需要完全隐藏IP地址或绕过特定网络限制的情况。</p>
<h4><strong>规则代理（Rule-based Proxy）模式</strong>：</h4>
<p>规则代理模式是根据预先定义的规则，选择性地将特定的网络流量通过代理服务器进行转发的模式。在规则代理模式下，您可以设置一系列规则，这些规则可以基于域名、IP地址、URL路径等来决定是否使用代理服务器转发请求。规则代理模式允许您更加灵活地控制代理的使用，可以根据不同的需求和场景进行定制。</p>
<h3>代码中的<code>0</code></h3>
<ol>
<li><code>if</code>条件中的0</li>
</ol>
<ul>
<li>条件 0 的求值结果为 false，因为大多数编程语言中，值为 0 被认为是 false，而非零值被认为是 true。因此，在 if 语句中的代码将不会被执行。</li>
</ul>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
int main() {
    if (0) {
        printf(&quot;这段代码不会被执行。\n&quot;);
    } else {
        printf(&quot;这段代码会被执行。\n&quot;);
    }
    return 0;
}
</code></pre>
<ol start="2">
<li><code>exit()</code>中的0</li>
</ol>
<p>exit(0) 是一个函数调用，用于在程序中终止执行并返回一个退出状态码。在C语言中，exit() 函数用于正常退出程序。
具体到 exit(0)，它表示程序成功地执行完毕并以状态码 0 退出。在大部分操作系统中，状态码 0 表示程序成功执行，没有发生错误。</p>
<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int main() {
    printf(&quot;程序执行完毕！\n&quot;);
    exit(0);
}
</code></pre>
<p>3.正确使用<code>.gitignore</code>
.gitignore 是一个用于指定 Git 版本控制系统忽略哪些文件和文件夹的配置文件。当你在 Git 仓库中创建 .gitignore 文件并指定要忽略的内容后，Git 在进行版本控制时将自动忽略这些文件和文件夹，不对其进行跟踪或提交。</p>
<p>.gitignore 文件的语法规则如下：</p>
<p>每一行表示一个要忽略的模式。
使用斜杠（/）指定目录或文件夹。
使用星号（*）表示通配符，匹配零个或多个字符。
使用问号（?）表示通配符，匹配一个字符。
使用感叹号（!）表示取反，即不忽略该模式匹配到的内容。
使用井号（#）表示注释，该行后面的内容将被忽略。</p>
<pre><code class="language-bash"># 忽略编译生成的文件
*.o
*.exe

# 忽略目录
/build/
/dist/

# 不忽略特定文件
!src/main.c
</code></pre>
<p>4.<code>pull request</code>
Pull Request（PR）是一种在分布式版本控制系统中协作开发的机制，常见于Git仓库管理工具（如GitHub、GitLab、Bitbucket等）。它允许开发者将自己的代码变更贡献给项目的原始代码库，并请求原始代码库的维护者合并这些变更。</p>
<blockquote>
<p>要在 GitHub 上创建 Pull Request，您需要按照以下步骤操作：</p>
</blockquote>
<ul>
<li>Fork 项目：访问您要贡献代码的原始项目页面，点击页面右上角的 &quot;Fork&quot; 按钮。这将在您的 GitHub 账户中创建一个该项目的副本。</li>
<li>克隆仓库：在您的 GitHub 账户中找到 Fork 后的项目，点击 &quot;Code&quot; 按钮并获取仓库的克隆 URL。在本地使用 Git 命令或 Git 客户端，使用该克隆 URL 将仓库克隆到您的本地环境中。</li>
<li>创建新分支：在本地仓库中创建一个新的分支，用于进行您的代码更改。可以使用 git checkout -b branch-name 命令来- - 创建并切换到新分支，其中 branch-name 是您为分支指定的名称。</li>
<li>进行代码更改：在新分支上进行代码更改，根据您的需求添加、修改或删除代码文件。</li>
<li>提交代码：将代码更改提交到新分支中。使用 Git 命令 git add 将更改的文件添加到暂存区，然后使用 git commit 提交更改，并使用 -m 参数添加提交消息。</li>
<li>推送分支：使用 git push origin branch-name 命令将您的新分支推送到您的 GitHub 仓库。</li>
<li>创建 Pull Request：在您的 GitHub 仓库页面上，切换到新分支，点击 &quot;Pull Request&quot; 或 &quot;New Pull Request&quot; 按钮。</li>
<li>比较更改：确保 &quot;base repository&quot; 是指向原始项目，&quot;base&quot; 分支是您要将更改合并到的目标分支，&quot;head repository&quot; 是指向您的仓库，&quot;compare&quot; 分支是您的新分支。</li>
<li>提交 Pull Request：检查 Pull Request 的详细信息，包括标题、描述和更改的文件。确认后，点击 &quot;Create Pull Request&quot; 提交您的 Pull Request。</li>
<li>等待审核：项目维护者将会对您的代码进行审核和评审。他们可能会提出问题、建议修改或讨论更改。</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/26"/><category term="疑问🤔"/><published>2024-02-27T16:29:26+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/24</id><title>Last week of  Febernuary</title><updated>2024-03-30T15:05:10.218290+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>其实也可以算作是3月的第一周，但前天还是元宵节，姑且还算做是正月，那就结尾吧。✍️</p>
</blockquote>
<h1>2024年02月26日 22:49:12 begin</h1>
<ul>
<li>hot 100</li>
<li>准备面试</li>
<li>学习</li>
<li>寻找工作
....... </li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/24"/><category term="周记"/><published>2024-02-26T14:51:40+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/22</id><title>银鞍照白马，洒踏如流星。</title><updated>2024-03-30T15:05:10.320154+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>为什么起这么名字，因为最近太背了，我希望自己能过得潇洒一点。看罗翔老师的《十三邀》采访，听他念一遍这句诗就喜欢上了，如此洒脱不羁，以前的我也是这样的哈哈。我已经23了，我总是疏于表达自己的情感，想得很好，实施起来却非常的困难，喜欢就是喜欢，不喜欢就是不喜欢，撞到南墙之后才知道南墙到底硬不硬，快速试错，降低犯错的机会成本，从错误中寻找正确，人总是要犯错的，完美主义不可行。</p>
</blockquote>
<ul>
<li>最近一年发生了许多事情，让我陷入了一个又一个循环中，失败又失败。颓废且丑陋，因为我改变不了别人，也改变不了自己，那就让自己一天一天的变好。 </li>
</ul>
<h1>毕业季</h1>
<p>看到其他同学的未来是那样的光明有着落，再看看自己，朋辈的压力一点也不小，可是没有人理解，只是一个劲的去催促，非常非常的down</p>
<h1>找工作</h1>
<p>大海捞针，沉默的大多数，个人的命运在时代的滚滚洪流之下简直不值一提，可是没有人在乎，这一切只能归于你【自己】的原因。这就是廉价劳动力的命，这就是社会现实。</p>
<h1>年底</h1>
<p>真的快撑不过去了，我的快乐被一点一点的榨干，只剩下麻木的躯壳。今年过年那就不回去了，反正也是那样，没有人真正的关心我，只是关心我有没有有用，有没有丢他的脸面，虚伪和丑陋和霸权，让我绝望，感觉像是原始社会。7月份的辱骂，正月的指责，他自己没有用，却将我一次又一次的推到悬崖之上。</p>
<h1>now</h1>
<ul>
<li>先找到一份工作，最好是c++相关的。</li>
<li>拯救坏情绪。</li>
<li>早起</li>
<li>将自己的烦恼写出来，一条一条的陈列。</li>
<li>健身</li>
<li>健康饮食</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/22"/><category term="周记"/><published>2024-01-21T15:25:57+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/21</id><title>周记</title><updated>2024-03-30T15:05:10.409563+00:00</updated><content type="html"><![CDATA[<p>见贤思齐
灵感来源:https://coldrain.ink/#/home
有计划➕执行力强➕web3：<a href="https://polebug.github.io/">https://polebug.github.io/</a></p>
]]></content><link href="https://github.com/dululu/notes/issues/21"/><category term="周记"/><published>2024-01-17T20:45:12+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/20</id><title>Neovim </title><updated>2024-03-30T15:05:10.519081+00:00</updated><content type="html"><![CDATA[<h3>Step1:安装<a href="https://github.com/neovim/neovim/blob/master/INSTALL.md">Neovim</a></h3>
<p>Ubuntu+WSL</p>
<pre><code class="language-powershell-interactive">sudo apt-get install python-dev python-pip python3-dev
sudo apt-get install python3-setuptools
sudo easy_install3 pip
//卸载
sudo cmake --build build/ --target uninstall
</code></pre>
<h3>Step2:Neovim 基础配置</h3>
<p>Neovim 配置文件不是<code> .vimrc</code></p>
<p>而是保存在<code> ~/.config/nvim/init.vim</code>,但是 init.vim 只作为入口，真正的配置，是加载的其他的 lua 配置文件
<a href="https://martinlwx.github.io/zh-cn/config-neovim-from-scratch/">写的太好了😎😎😎</a></p>
<p>😅 然而我还没弄好 @dululu [2024年01月14日 23:21:49] </p>
]]></content><link href="https://github.com/dululu/notes/issues/20"/><published>2024-01-14T15:21:59+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/19</id><title>C++</title><updated>2024-03-30T15:05:10.614435+00:00</updated><content type="html"><![CDATA[<ol>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129283639">c++基础/类和对象</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129318605">c++继承机制</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129325451">虚函数与多态性</a></li>
<li><a href="https://blog.csdn.net/Neo_21/article/details/129407024">c++指针</a></li>
</ol>
<p><strong>https://github.com/jiayuancs/Cpp-Primer</strong></p>
]]></content><link href="https://github.com/dululu/notes/issues/19"/><category term="cpp"/><published>2024-01-11T16:13:14+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/18</id><title>快速学习C和C++，基础语法和优化策略（三）</title><updated>2024-03-30T15:05:10.711488+00:00</updated><content type="html"><![CDATA[<h3>函数 functions</h3>
<h4>内联函数 inline</h4>
<p>程序运行效率,用空间换时间。</p>
<pre><code class="language-cpp">// 使用函数调用
int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = max_function(num1,num2);
    maxv = max_function(numn,maxv);
}
//
float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
//频繁调用max_function
</code></pre>
<p>可以用<code>inline</code>,用空间换时间。</p>
<pre><code class="language-cpp">int main()
{
    int num1 =20;
    int num2 = 30;
    int maxv = {   //示意图，没有函数调用，生成的机器代码变多。
    if(num1&gt;num2)
        return num1;
    else
        return num2;}
    maxv = {
    if(numn&gt;maxv)
        return numn;
    else
        return maxv;}
}
// 只会建议编译器执行这样的命令，编译器根据整体情况来判断
inline float max_function(float a,float b)
{
    if(a&gt;b)
        return a;
    else
        return b;
}
</code></pre>
<p>使用<code>宏</code>操作</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
//num1 =21,因为num1没有被再次调用
</code></pre>
<h4>默认参数 Default arguments</h4>
<ul>
<li>
<p>默认参数要从尾部开始设
<img width="584" alt="image" src="https://github.com/dululu/notes/assets/64392262/8e579ce4-9d4e-4f55-b2b3-a6548fa949cf"></p>
</li>
<li>
<p>默认参数不能重定义，每个参数只能有一个默认值</p>
</li>
</ul>
<h4>函数重载 overloading</h4>
<p>使用同样的<strong>函数名</strong>，但是做的是不同的事。</p>
<pre><code class="language-cpp">&lt;cmath&gt;
double round(double x);
float round(flaot x);
long duble round(long double x);
</code></pre>
<p><code>cpp</code> 依赖参数列表来查询，选择不同的函数。</p>
<h4>函数模板 templates</h4>
<p>当函数的实现<strong>逻辑</strong>都非常相同的时候，就可以使用函数模板。</p>
<pre><code class="language-cpp">template&lt;typename T&gt;
T sum(T x, T y)
{
cout&lt;&lt;&quot;The input type is&quot; &lt;&lt; typeid(T).name &lt;&lt;endl;
return x+y;
}
// 实例化
template double sum(double,double);
template char sum&lt;&gt;(char,char);
template int sum(int,int);
</code></pre>
<h4>函数指针和函数引用 Function pointers and References</h4>
<ul>
<li>函数指针</li>
</ul>
<pre><code class="language-cpp">norm_ptr //指针指向指令区
float norml1(float x, float y);
float norml2(float x, float y);
float (*norm_ptr)(float x, float y);
</code></pre>
<ul>
<li>函数引用</li>
</ul>
<pre><code class="language-cpp">float norml1(float x, float y);
float norml2(float x, float y);
float (&amp;norm_ptr)(float x, float y) = norml1;
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/18"/><category term="Skills"/><category term="cpp"/><published>2024-01-11T06:35:36+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/17</id><title>快速学习C和C++，基础语法和优化策略。（二）</title><updated>2024-03-30T15:05:10.811589+00:00</updated><content type="html"><![CDATA[<h3>P5:结构</h3>
<h4>结构体，联合体，枚举类型</h4>
<ul>
<li><code>struct</code> 定义结构体</li>
</ul>
<pre><code class="language-cpp">struct Student{
    char name[4];
    int born;
    bool male;
};
struct Student stu;
strcpy(stu.name,&quot;X&quot;);
stu.born = 2000;
stu.male = false;

struct Student stu = {&quot;K&quot;,23,true} //初始化，c语言必须要前面的struct
</code></pre>
<p>在c++中class和struct几乎没区别。</p>
<ul>
<li>union
所有成员共享同一个内存，有相同的地址，只是长度不同</li>
</ul>
<img width="265" alt="image" src="https://github.com/dululu/notes/assets/64392262/4c1dd929-7564-49b7-ab0d-d69a232d221e">
<pre><code class="language-cpp">union ipv4address{
    std::unit32_t address32;
    std::unit8_t address[4];
//首地址相同，以最大的对象所占的内存大小为准。
}
</code></pre>
<ul>
<li>enum 枚举</li>
</ul>
<blockquote>
<p>enum make a new type</p>
</blockquote>
<pre><code class="language-cpp">enum color {white,black,blue,red,pink,yellow,num_color}
enum color pen_color = blue;
pen_color = color(3);
</code></pre>
<h4>指针 Pointers</h4>
<pre><code class="language-cpp">&amp; //去变量或对象的地址
* //对指针取内容，取地址里面的那块内容
int *p1 = NULL, *p2 =NULL;
</code></pre>
<ul>
<li><code>p-&gt;member</code></li>
<li><code>(*p).member</code></li>
</ul>
<h4>内存管理 Allocate memory</h4>
<ul>
<li><code>C</code>
<code>Heap</code>:堆，动态申请内存
<code>stack</code>:栈，局部变量，临时变量，<code>int i</code>
堆栈相向而行。
<img width="203" alt="image" src="https://github.com/dululu/notes/assets/64392262/01c6886d-dd60-43f5-ac83-bbed9643be44"></li>
</ul>
<pre><code class="language-cpp">int a = 0;
int b = 0;
int c = 0; 
cout&lt;&lt;&amp;a&lt;&lt;&amp;b&lt;&lt;&amp;c&lt;&lt;endl;

int *p1 = (*int) malloc(4);
int *p2 = (*int) malloc(4);
int *p3 = (*int) malloc(4);
cout&lt;&lt;p1&lt;&lt;p1&lt;&lt;p3&lt;&lt;endl;
</code></pre>
<img width="191" alt="image" src="https://github.com/dululu/notes/assets/64392262/55fba445-8fbd-488d-a938-b707dd77181a">
<blockquote>
<ul>
<li>abc地址越来小，地址连续。</li>
<li>p1p2p3地址越来越大，malloc(4)分配4个字节,9-a-b,每一个差16个字节，但地址是16位对齐,所以剩下的4个字节就浪费掉了。</li>
</ul>
</blockquote>
<ul>
<li>申请内存 Memory allocation</li>
</ul>
<pre><code class="language-cpp">void* malloc(size_t size)
int * p1 =  (int*)malloc(4);//初始化
free（p1）;释放内存
</code></pre>
<ul>
<li><code>c++</code></li>
</ul>
<pre><code class="language-cpp">new//
int *p1 = new int;
int *p2 = new int();
int *p3 = new int(5);
int *p1 = new int{};
//
int *pad = new int[16];
int *p9 = new Student[16];
//释放
delete p1;
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/17"/><category term="Skills"/><category term="cpp"/><published>2024-01-10T17:34:56+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/16</id><title>炒蛋问题</title><updated>2024-03-30T15:05:10.906032+00:00</updated><content type="html"><![CDATA[<p><a href="https://poe.com/ChatGPT">为什么不问一问GPT呢😊😊😊</a></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> gdb是啥？</li>
<li><input checked="" disabled="" type="checkbox"> 为啥WSL可以编译cpp</li>
<li><input checked="" disabled="" type="checkbox"> 常见单位换算</li>
<li><input checked="" disabled="" type="checkbox"> 为什么是2^32^B</li>
<li><input checked="" disabled="" type="checkbox"> ++i 和 i++</li>
<li><input checked="" disabled="" type="checkbox"> clang 与 g++</li>
<li><input checked="" disabled="" type="checkbox"> linux常用命令1️⃣</li>
</ul>
<h3>gdb是啥？</h3>
<ul>
<li>GNU Debugger</li>
</ul>
<blockquote>
<p>gdb是一种由GNU开发的免费的调试器，它可以帮助程序员在开发过程中定位和修复代码中的错误。它提供了一系列命令和功能，可以帮助用户查看程序的内部状态、执行代码步骤、跟踪变量的值等。</p>
</blockquote>
<h3>为啥WSL可以编译cpp</h3>
<blockquote>
<p>WSL是Windows Subsystem for Linux的缩写，它允许Windows用户在其系统上运行Linux环境。因此，通过WSL，用户可以使用Linux上的编译器和工具来编译和运行C++程序。</p>
</blockquote>
<ul>
<li>为了编译C++程序，您还需要安装g++编译器。它是GNU编译器集合中专门用于编译C++程序的工具，可以将源代码编译成可执行文件。在WSL中，您可以通过apt-get命令来安装g++。</li>
<li>可以使用命令“g++ --version”来查看系统中是否已安装g++，以及其版本信息。如果系统中没有安装，您可以通过apt-get命令来安装。
<img width="357" alt="image" src="https://github.com/dululu/notes/assets/64392262/db79ccb8-5c41-478b-b015-d3116528821a"></li>
</ul>
<h3>常见单位换算</h3>
<ul>
<li>1 byte = 8 bit
电脑<strong>存储</strong>的单位有 B（字节）、KB（千字节）、MB（兆字节）、GB（千兆字节）、TB（太字节）和 PB（拍字节）。</li>
<li>
它们之间的换算关系为：<ul>
<li>1 KB = 2 的 10 次方 B，</li>
<li>1 MB = 2 的 20 次方 B，</li>
<li>1 GB = 2 的 30 次方 B，</li>
<li>1 TB = 2 的 40 次方 B，</li>
<li>1 PB = 2 的 50 次方 B。</li>
</ul>
</li>
<li>
通常用来表示<strong>网速</strong>的单位有 bps（每秒比特数）、Kbps（千比特每秒）、Mbps（兆比特每秒）和 Gbps（千兆比特每秒）。它们之间的换算关系为：<ul>
<li>1 Kbps = 2 的 10 次方 bps，</li>
<li>1 Mbps = 2 的 20 次方 bps，</li>
<li>1 Gbps = 2 的 30 次方 bps。</li>
</ul>
</li>
</ul>
<h3>为什么是2^32^B</h3>
<p><a href="https://www.zhihu.com/question/423135323">nice</a>
注意区分<strong>容量</strong>和<strong>长度</strong></p>
<p>说长度的时候就是说这个地址有几个bit</p>
<p>说容量的时候，意思是在这个地址长度下，最多可能存储多少bit</p>
<blockquote>
<ul>
<li>我们可以说一个32位<code>int</code>型变量占的空间为4B，也可以说计算机里面一个32位寄存器可以记录的数据量为4B</li>
<li>32位机时代因为<strong>计算机寄存器</strong>的的容量为32位，那么如果我们只想<strong>用一个寄存器来储存一个内存地址</strong>的话，那么我们最多可以表示2的32次方个不同的内存地址，然后每个内存地址下可以存储1B也就是8bit的信息(<strong>注意不是每个位都有自己的地址)</strong>，所以这种设定下支持的最大内存容量就是2^32B = 2^22KB = 2^12MB = 2^2G = 4G。当然这只是一个上界，有时候内存特殊地址有特殊作用，所以事实上32位Windows支持的最大内存没那么大。</li>
<li>一个地址控制一个字节，所以最终结果是2^32B,计算机中存储器以字节（B）为基本单位。</li>
</ul>
</blockquote>
<h3>++i 和 i++</h3>
<p>两者都是 C++ 中的自增运算符，i++ 表示先使用 i 的值，再对 i 进行加 1 操作，++i 表示先对 i 进行加 1 操作，再使用 i 的值。它们在大多数情况下都可以达到相同的效果，但是在某些特殊情况下会有差异，比如在 for 循环中的使用。</p>
<pre><code class="language-cpp">#define MAX_MACRO(a&gt;b) ?(a):(b)  //比较大小
// 不局限于某一种特定的数据类型
// 宏 是文本替换
int num1 = 20,num2 = 30;
maxv = MAX_MACRO(num1++,num2++);
maxv = MAX_MACRO(num1++ &gt; num2++) ?(num1++):(num2++) 
cout&lt;&lt; maxv &lt;&lt; endl;  //31
cout &lt;&lt;&quot;num2=&quot;&lt;&lt;num2&lt;&lt;endl; //mun2=32
</code></pre>
<h4>clang 与 g++</h4>
<p><strong>系统(W/L)-&gt;编译器(clang/g++)-&gt;</strong>
<code>/$</code> 根目录的符号
<code>~$</code> 当前用户的主目录的符号<br />
<code>sudo</code> 是Linux系统中用来获得超级用户权限的命令。使用sudo可以让您以超级用户的身份来运行指定的命令。</p>
<h5>为了在WSL 2中安装Clang，您可以使用WSL提供的apt-get命令来安装。具体的操作步骤如下：</h5>
<ul>
<li>打开WSL 2终端。</li>
<li>运行命令&quot;sudo apt-get update&quot;来更新软件源。</li>
<li>运行命令&quot;sudo apt-get install clang&quot;来安装Clang。</li>
<li>安装完成后，您可以使用命令&quot;clang -v&quot;来验证安装是否成功。</li>
<li><code>clang -std==c++11 1.cpp</code></li>
</ul>
<h4>常用命令</h4>
<h5>文件管理</h5>
<ul>
<li>路径</li>
</ul>
<pre><code class="language-powershell">cd . 当前
cd.. 上一级
cd / 根
cd ~/ 家
</code></pre>
<ul>
<li>文件</li>
</ul>
<pre><code class="language-powershell">mkdir xxx 创建目录
rm xxx 删除文件 rm xx -r 删除文件夹
mv xxx yy 移动文件/重命名
touch xx 创建文件
cat xx 展示文本
</code></pre>
<ul>
<li>tmux 和 vim
<code>vim-session-pane</code> 平时一般只用一个<code>session</code>，一个<code>session</code>打开多个<code>pane</code></li>
</ul>
<pre><code class="language-powershell">`C+b %` 左右
`C+b “”` 上下
`C+d` 关闭pane
`C+b+d` 挂起session
`tmux+a` 打开挂起的session
</code></pre>
]]></content><link href="https://github.com/dululu/notes/issues/16"/><category term="疑问🤔"/><published>2024-01-08T16:56:58+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/15</id><title>快速学习C和C++，基础语法和优化策略（一）</title><updated>2024-03-30T15:05:11.005667+00:00</updated><content type="html"><![CDATA[<p><strong>视频</strong>：<a href="https://www.bilibili.com/video/BV1Vf4y1P7pq/">ysq</a><br />
<strong>文档</strong>: <a href="https://github.com/ShiqiYu/CPP/tree/main/week01">github</a></p>
<blockquote>
<p>只是差缺补漏，快速过一遍💨💨💨</p>
</blockquote>
<ul>
<li>基础知识：以点带面</li>
<li>
本课重点： <strong>指针和内存管理</strong><ul>
<li><strong>程序效率提升；</strong></li>
<li>介绍OpenCV采用c++特性设计cv::Mat类</li>
<li>介绍ARM开发：ARM开发与Intel的x86开发没有区别。嵌入式ARM，智能设备/ARM服务器。</li>
</ul>
</li>
</ul>
<h2>基础知识</h2>
<h3>P1:编译 Compile</h3>
<ul>
<li>编译C++代码：g++编译器</li>
</ul>
<pre><code class="language-cpp">g++ hello.cpp
g++ hello.cpp  --std=c++11  //告诉编译器采用哪一个标准
//执行成功，生成可执行文件a.out
g++ hello.cpp  --std=c++11 -o hello //更改执行文件名
./hello    //执行
</code></pre>
<ul>
<li>
<p>计算机编程语言发展历史</p>
<ul>
<li>
<p>二进制指令（Binary instructions for CPU）: 纸带打孔表示0和1
<img width="292" alt="屏幕截图 2024-01-08 160010" src="https://github.com/dululu/notes/assets/64392262/2732d2af-d738-4ec2-8378-862c4922b39e"></p>
</li>
<li>
<p>汇编语言（assembly language）</p>
</li>
<li>
<p>高级编程语言（high level language）：</p>
<ul>
<li>C:1973  </li>
<li>C++:1979，c with class</li>
<li>Java:1995 生成字节码class文件</li>
<li>Python:1990 脚本语言</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>编译和链接</strong>
<img width="471" alt="屏幕截图 2023-08-06 153029" src="https://github.com/dululu/notes/assets/64392262/8d6d194d-546e-4828-a15d-ec4b475ca8f4"></p>
</li>
<li>
<p>函数的声明和定义(实现)</p>
</li>
</ul>
<pre><code class="language-cpp">
int mul(int a, int b);  //*.h

int mul(int a, int b) // *.c,*.cpp
{
    return a * b;
}
</code></pre>
<ul>
<li>
<strong>debug</strong><ul>
<li>编译错误：语法错误，如漏了分号</li>
<li>链接错误：Mul.o 与 mul.o</li>
<li>运行时错误：如除数为0，2/0  </li>
</ul>
</li>
</ul>
<h3>P2 预处理和宏 Preprocessor and Macros</h3>
<p><em>在编译之前的步骤</em></p>
<ul>
<li>
<p>定义规则</p>
<ul>
<li>以<code>#</code>开头</li>
<li>每个预处理指令只能占一行</li>
</ul>
</li>
<li>
<p>宏定义</p>
</li>
</ul>
<pre><code class="language-cpp">#define PI 3.14 // PI 不是变量，因为不可改变，理解为文字替换
</code></pre>
<ul>
<li>
<strong>为了避免同一个头文件被包含（include）多次，C/C++ 中有两种宏实现方式：</strong><ul>
<li><code>#pragma once</code></li>
</ul>
<pre><code class="language-cpp">  方式一：
  #ifndef __SOMEFILE_H__
  #define __SOMEFILE_H__
  ... ... // 一些声明语句
  #endif

  方式二：
  #pragma once
  ... ... // 一些声明语句,好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题
</code></pre>
<ul>
<li><code> #ifndef / #define</code></li>
</ul>
<pre><code class="language-cpp">  #ifndef __XXX_H__
  #define __XXX_H__
  int a=1;
  #endif    // 如果没有定义宏__XXX_H_,执行；如果已经定义了，直接结束。变量 a 只被定义一次
  //通过宏定义解决头文件重复包含。
</code></pre>
</li>
</ul>
<h3>P3 简单输入和输出</h3>
<h5>cpp</h5>
<ul>
<li>关于<code>std::ostream cout</code>
<em>c++并未定义任何输入输出语句，取而代之，包含了一个全面的<strong>标准库</strong>(std)来提供IO机制。许多例子都是使用<strong>iostream</strong>，来表示输入输出流。</em></li>
<li><strong>ostream</strong> 是一个数据类型，与<code>int</code>,<code>bool</code>类似</li>
</ul>
<blockquote>
<p>cout is an object of data type ostream in namespace std.
cout是命名空间std中数据类型为ostream的对象。
cin 是 istream</p>
</blockquote>
<ul>
<li><code>&lt;&lt;</code>是一个operator运算符</li>
</ul>
<pre><code class="language-cpp">cin &gt;&gt; a; //从标准输入读数据转成整数类型，存到a里面去。
cout &lt;&lt; &quot;打印&quot;;
</code></pre>
<ul>
<li>运算符重载</li>
</ul>
<pre><code class="language-cpp">    data1 + data2;
    operator+(data1,data2);//等价的函数调用
</code></pre>
<h4>c</h4>
<p>c语言风格输出，<code>printf</code></p>
<ul>
<li><code>int printf(const char *format,....)</code></li>
</ul>
<pre><code class="language-cpp">int v = 100;
printf(&quot;Hello,value = %d\n&quot;, v);
</code></pre>
<p>输入:<code>scanf</code></p>
<pre><code class="language-cpp">int v;
int ret = scanf(&quot;%d&quot;,&amp;v);
</code></pre>
<h3>P4 常见数据类型</h3>
<h4><code>int</code></h4>
<img width="437" alt="屏幕截图 2024-01-10 164256" src="https://github.com/dululu/notes/assets/64392262/af10f131-088c-40d8-a5d5-e54a85743779">
<ul>
<li>
<p><code>short int</code> 2个字节16位</p>
</li>
<li>
<p><code>int</code> <strong>一般都是</strong>32位，</p>
<blockquote>
<p>有符号整数<code>int</code></p>
<ul>
<li>max:0111 1111 1111 1111 1111 1111 1111 1111 =2^31^-1</li>
<li>min: 1111 1111 1111 1111 1111 1111 1111 1111 = -2^31^  （多一个负数的最大值）
低31位存数值，最高位存符号</li>
</ul>
</blockquote>
<blockquote>
<p>无符号整数 <code>unsigned int</code></p>
<ul>
<li>max:1111 1111 1111 1111 1111 1111 1111 1111 =2^32^-1</li>
<li>min:0
32位都用来存数值，所以可以存放16位数乘以16位数的数</li>
</ul>
</blockquote>
</li>
</ul>
<img width="457" alt="image" src="https://github.com/dululu/notes/assets/64392262/037b3596-913c-4264-ba8d-c429f260276c">
<h4><code>sizeof()</code>返回当前数值占多少个字节</h4>
<ul>
<li>sizeof不是一个函数，函数的参数必须是<strong>变量</strong>。sizeof(int)是一个操作符。 </li>
</ul>
<pre><code class="language-cpp"> int i = 0;
 cout&lt;&lt;&quot;sizeof(int)=&quot; sizeof(i) &lt;&lt;endl; //i 不是变量，是一个常量。
</code></pre>
<h4><code>char</code></h4>
<ul>
<li><code>char</code>: <strong>8-bit integer indeed!</strong></li>
<li><code>singned char</code>:-128——127</li>
<li><code>unsigned char</code>:0——255</li>
<li>字符本身就是整数，按照编码。<code>ASCII</code>码</li>
</ul>
<blockquote>
<ul>
<li>中文表示
<code>char16_t</code>,<code>char32_t</code></li>
</ul>
</blockquote>
<h4><code>bool</code></h4>
<p>字节是最小的存储单元,<code>bool</code>占一个字节，8位
<code>bool  d = -21</code>;    只要不是<code>0</code>，那么赋值就是<code>1</code></p>
<h4><code>size_t</code></h4>
<p>无符号整数类型，一般表达<strong>内存大小，元素的个数</strong>。</p>
<ul>
<li>返回电脑支持的最大位数</li>
</ul>
<h4>定义一些符号和宏的使用。</h4>
<img width="287" alt="image" src="https://github.com/dululu/notes/assets/64392262/c7e2f322-f4ef-4dcf-bf8d-ade2557a854e">
<h4>浮点数float</h4>
<img width="559" alt="image" src="https://github.com/dululu/notes/assets/64392262/cff54b1e-8955-45f7-8cf3-079ea925b4a2">
<blockquote>
<p>2.34E+10f : 可以表示为 23400000000，即 234 亿。其中，E 表示 10 的指数，+10 表示 10 的 10 次方，f 表示浮点数。</p>
</blockquote>
<ul>
<li>
32位单精度浮点数<ul>
<li>符号位</li>
<li>系数</li>
<li>精度</li>
</ul>
</li>
<li>double,64位</li>
<li>long double</li>
</ul>
<h4>数组 array[]</h4>
<blockquote>
<ul>
<li>连续的内存,在Java中是一个对象。</li>
<li>可以是存储任何数据类型</li>
</ul>
</blockquote>
<ul>
<li>未知长度的数组，长度由初始化决定。</li>
</ul>
<pre><code class="language-cpp">int num_array[] = {1,3,4,6};// 4 int
</code></pre>
<ul>
<li>把数组传递给函数内部。</li>
</ul>
<blockquote>
<p>values[]是一个指针，代表数组的<strong>首地址</strong>，size_t数组&gt;的长度。</p>
</blockquote>
<pre><code class="language-cpp">//float类型的指针
float array_sum(values[], size_t length);
float array_sum(*values, size_t length);
</code></pre>
<ul>
<li>
<p>数组元素的读写
<code>array1</code>,<code>array2</code>是数组的首地址
<img width="292" alt="image" src="https://github.com/dululu/notes/assets/64392262/da539a3d-efed-44b4-95aa-c26c888dd164"></p>
</li>
<li>
<p>越界</p>
<blockquote>
<p>没有边界检查，在c++中。如果发生越界，按照地址的逻辑直接去进行读和写。</p>
</blockquote>
<ul>
<li>在c++中，数组不是一个对象；<strong>数组是一块连续的内存，数组名指向首地址 ，大小不知道。</strong></li>
<li>缺点：易出错    优点：没有边界检查，效率高</li>
</ul>
</li>
<li>
<p>多维数组
当使用数组名作为<strong>首地址</strong>的时候，必须指定<strong>列</strong>数，不然找不到下一行。 确定偏移的位置。</p>
</li>
</ul>
<img width="563" alt="image" src="https://github.com/dululu/notes/assets/64392262/8f5af34b-a194-4d27-a171-f82da1bf7e79">
<img width="290" alt="image" src="https://github.com/dululu/notes/assets/64392262/382c76d0-1289-4181-adc4-cf52e6bca811">
<h4>字符串 String</h4>
<ul>
<li>
<p>Array-style Strings <strong>数组类型字符串</strong>
最后<strong>一定要加一个0</strong>，来结束字符串。<strong>'\0'</strong> 整数值为0，字符到此为止。否则就会发生越界。
<img width="568" alt="image" src="https://github.com/dululu/notes/assets/64392262/30e4e031-d80d-43fc-b532-3abf3e9ad28d"></p>
</li>
<li>
<p>strlen()返回字符的<strong>数量</strong>,遇到‘\0’就会终止。</p>
</li>
</ul>
<pre><code class="language-cpp">    size_t strlen(const char *str);
</code></pre>
<ul>
<li>常见的字符串</li>
</ul>
<img width="614" alt="image" src="https://github.com/dululu/notes/assets/64392262/549305e1-1c62-4250-a38b-c6d952790231">
<img width="603" alt="image" src="https://github.com/dululu/notes/assets/64392262/374d10eb-3abd-4c60-8d97-bdfdc377b07b">
<p><strong>数组长度为5，字符串长度为4</strong></p>
<ul>
<li>String class
string可以<strong>直接使用运算符</strong>对字符串进行操作。string类没有越界检查
<img width="617" alt="image" src="https://github.com/dululu/notes/assets/64392262/3cb6200f-588d-4207-b89f-0d2c5c2f4988"></li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/15"/><category term="Skills"/><category term="cpp"/><published>2024-01-08T05:46:40+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/11</id><title>24-3</title><updated>2024-03-30T15:05:11.139351+00:00</updated><content type="html"><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> yihong的2022总结，本博来源。</li>
<li><input checked="" disabled="" type="checkbox"> 汉语拼音的<code>ü</code>与<code>v</code></li>
<li><input checked="" disabled="" type="checkbox"> 八股--干就完了😊</li>
<li><input checked="" disabled="" type="checkbox"> cpp primer 5</li>
</ul>
<h2><a href="https://github.com/yihong0618/2020?tab=readme-ov-file">yihong2022</a></h2>
<ul>
<li>有计划才有动力</li>
<li>劳逸结合，工作生活两手抓</li>
</ul>
<h2><a href="https://pub.bnu.edu.cn/jzyg1/127880.html">九键输入法完全失败😅</a></h2>
<ul>
<li>把<code>ü</code>写成<code>v</code></li>
<li>键盘上没有标示“ü”的键，实际中是用“v”所在的键来表示ü。</li>
<li>驴-&gt;lv ; 女-&gt;nv</li>
<li>拼音字母ü没有给出对应的大写形式, 国际： LYU XIAOJUN（吕小军Lü Xiaojun，奥运会举重冠军），国内“Lü DONGBIN”吕洞宾</li>
<li><code>u</code> <code>v</code>混用， qv-qu-&gt;去；ju-jv-举；</li>
</ul>
<h2><a href="https://github.com/jaywcjlove/reference/blob/main/docs/cpp.md">C++ 备忘清单</a></h2>
<h2><a href="https://github.com/applenob/Cpp_Primer_Practice">Cpp_Primer_Practice</a></h2>
]]></content><link href="https://github.com/dululu/notes/issues/11"/><category term="Top"/><category term="收藏文章"/><published>2024-01-06T18:04:47+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/9</id><title>需要学习的东西</title><updated>2024-03-30T15:05:11.239698+00:00</updated><content type="html"><![CDATA[<ul>
<li><input disabled="" type="checkbox"> #2 </li>
<li><input disabled="" type="checkbox"> #20 </li>
<li><input disabled="" type="checkbox"> 写周记，复盘，记单词，刷leetcode</li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/9"/><category term="TODO"/><published>2024-01-06T16:54:19+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/7</id><title>链接</title><updated>2024-03-30T15:05:11.341134+00:00</updated><content type="html"><![CDATA[<p>格式如下（请参考我下面的 comment）:
冒号为中文冒号 ：</p>
<p>名字：xxxxxx
链接：xxxxxx
描述：xxxxxx</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> added
打心后会自动加到友情链接里。</li>
</ul>
<p>❤</p>
]]></content><link href="https://github.com/dululu/notes/issues/7"/><category term="Friends"/><published>2024-01-06T15:30:06+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/2</id><title>GitHubActions和github-pages</title><updated>2024-03-30T15:05:11.436295+00:00</updated><content type="html"><![CDATA[<blockquote>
<ul>
<li>最近想重新拾起写日记的习惯，想把blog部署在GitHub上，但是一直不清楚具体方法。<a href="https://polebug.github.io/aboutme/">polebug</a>,本地已经好了，学习如何自动化部署。</li>
<li>突然想在readme文件中实时显示leetcode的刷题数，正好可以用GitHub Actions来运行一个定时任务，定期更新Markdown文档中的刷题数</li>
</ul>
</blockquote>
<h2>怎样使用<code>Action</code></h2>
<ul>
<li><input disabled="" type="checkbox"> <a href="https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana">https://www.youtube.com/watch?v=R8_veQiYBjI&amp;ab_channel=TechWorldwithNana</a></li>
</ul>
]]></content><link href="https://github.com/dululu/notes/issues/2"/><category term="Skills"/><category term="Top"/><published>2024-01-04T17:29:14+00:00</published></entry><entry><id>https://github.com/dululu/notes/issues/1</id><title>博客页面</title><updated>2024-03-30T15:05:11.529273+00:00</updated><content type="html"><![CDATA[<h2><a href="https://laike9m.com/blog/people-die-but-long-live-github,122/">People Die, but Long Live GitHub</a></h2>
<ul>
<li>参考来源：<a href="https://github.com/yihong0618/gitblog/issues/209">yihong</a>&amp;<a href="https://github.com/yihong0618/gitblog/issues/177">这个博客开源了</a></li>
<li>
具体方法：<ul>
<li>将.github文件夹，main.py,requirments.txt复制到需要的文件夹下</li>
<li>生成github secret token,在yml文件中改成自己的</li>
<li>将yihong的readme文件复制过来，提交一个issue，创建一个label</li>
<li>刷新GitHub</li>
</ul>
</li>
<li>可以创建属于自己的分区</li>
</ul>
<blockquote>
<ul>
<li><strong>rss</strong> 将仓库名改为自己的仓库名,原始为gitblog,根目录下创建一个feed.xml文件</li>
<li><strong>友情链接</strong> 创建一个标签为<code>Friend</code>的<code>issue</code>,按照格就可自动添加，点上红心❤自动添加。<a href="https://github.com/yihong0618/gitblog/issues/217">详情</a></li>
<li><strong>todolist</strong> 创建一个标签为<code>TODO</code>的<code>issue</code>,注意issue的格式，<code>*</code>不可以，<code>-</code>可以正常显示。</li>
</ul>
</blockquote>
<p><em>跟据<code>label</code>和<code>comment</code>更改</em></p>
<pre><code>COOK_LABEL_LIST = [
    &quot;Cook&quot;,
]
MOVIE_LABEL_LIST = [
    &quot;Movie&quot;,
]
READ_LABEL_LIST = [
    &quot;Read&quot;,
]
DRAMA_LABEL_LIST = [
    &quot;Drama&quot;,
]
PUSHUP_LABEL_LIST = [
    &quot;PushUps&quot;,
]
BANGUMI_LABEL_LIST = [
    &quot;Bangumi&quot;,
]
GAME_LABEL_LIST = [
    &quot;Game&quot;,
]
MONEY_LABEL_LIST = [
    &quot;Money&quot;,
]
MEDITATION_LABEL_LIST = [
    &quot;Meditation&quot;,
]
MORNING_LABEL_LIST = [
    &quot;Morning&quot;,
]
GTD_LABEL_LIST = [
    &quot;GTD&quot;,
]
MY_BLOG_REPO = &quot;yihong0618/gitblog&quot;
GITHUB_README_COMMENTS = (
    &quot;(&lt;!--START_SECTION:{name}--&gt;\n)(.*)(&lt;!--END_SECTION:{name}--&gt;\n)&quot;
)

# add new label here
LABEL_DICT = {
    &quot;Cook&quot;: {&quot;label_list&quot;: COOK_LABEL_LIST, &quot;comment_name&quot;: &quot;my_cook&quot;},
    &quot;Movie&quot;: {&quot;label_list&quot;: MOVIE_LABEL_LIST, &quot;comment_name&quot;: &quot;my_movie&quot;},
    &quot;Read&quot;: {&quot;label_list&quot;: READ_LABEL_LIST, &quot;comment_name&quot;: &quot;my_read&quot;},
    &quot;Drama&quot;: {&quot;label_list&quot;: DRAMA_LABEL_LIST, &quot;comment_name&quot;: &quot;my_drama&quot;},
    &quot;Bangumi&quot;: {&quot;label_list&quot;: BANGUMI_LABEL_LIST, &quot;comment_name&quot;: &quot;my_bangumi&quot;},
    &quot;Game&quot;: {&quot;label_list&quot;: GAME_LABEL_LIST, &quot;comment_name&quot;: &quot;my_game&quot;},
}


##### SHANBAY ######
MY_SHANBAY_USER_NAME = &quot;ufewz&quot;
SHANBAY_CALENDAR_API = &quot;https://apiv3.shanbay.com/uc/checkin/calendar/dates/?user_id={user_name}&amp;start_date={start_date}&amp;end_date={end_date}&quot;
MY_SHANBAY_URL = f&quot;https://web.shanbay.com/web/users/{MY_SHANBAY_USER_NAME}/zone&quot;

##### DUO ######
MY_DUOLINGO_URL = &quot;https://www.duolingo.com/profile/yihong0618&quot;

##### CICHANG ######
MY_CICHANG_URL = &quot;https://twitter.com/yihong06181/status/1359040099107897344?s=20&quot;


##### FOOD ######
MY_FOOD_STAT_HEAD = (
    &quot;| Name | First_date | Last_date | Times | \n | ---- | ---- | ---- | ---- |\n&quot;
)
MY_FOOD_STAT_TEMPLATE = &quot;| {name} | {first_date} | {last_date} | {times} |\n&quot;

##### Month Summary ######
MONTH_SUMMARY_HEAD = &quot;| Month | Number | \n | ---- | ---- | \n&quot;

MONTH_SUMMARY_STAT_TEMPLATE = &quot;| {month} | {number} |\n&quot;
</code></pre>
<p>✍️</p>
]]></content><link href="https://github.com/dululu/notes/issues/1"/><category term="Skills"/><category term="Top"/><published>2024-01-03T18:37:05+00:00</published></entry></feed>